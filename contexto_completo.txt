CONTEXTO COMPLETO DO PROJETO
============================



==================================================
FILE: .\.aiexclude
==================================================
# Bloqueio de credenciais e ambiente
.env
*.pem
*.key

# Bloqueio de dados e logs de processamento (Polars/Data Lake)
**/data/*.parquet
**/data/*.csv
**/logs/

# Bloqueio de arquivos de infraestrutura sens√≠veis
docker-compose.override.yml
nginx/conf.d/

==================================================
FILE: .\.env.example
==================================================
# AMBIENTE
ENV=dev

# SECURITY
JWT_SECRET=JESUS_CRISTO_√â_O_MEU_SENHOR
JWT_ALGORITHM=HS256

# EXPIRATIONS
ACCESS_TOKEN_EXPIRE_MINUTES=15
REFRESH_TOKEN_EXPIRE_DAYS=7

# DATABASE
DB_BACKEND=sqlite
DB_DSN=./data/dados.db


==================================================
FILE: .\.gitignore
==================================================
__pycache__/
*.pyc
.env
# Backups de bancos na pasta data
/data/dados.bak_*.db
TEMP_todelete.txt


==================================================
FILE: .\migrate.py
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import annotations

import argparse
import hashlib
import importlib.util
import sqlite3
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple


@dataclass
class MigrationFile:
    version: int
    name: str
    path: Path
    kind: str  # 'sql' or 'py'
    checksum: str


def compute_checksum(content: bytes) -> str:
    return hashlib.sha256(content).hexdigest()


def discover_migrations(migrations_dir: Path) -> List[MigrationFile]:
    files: List[MigrationFile] = []
    for p in sorted(migrations_dir.glob("V*__*.*")):
        if p.suffix.lower() not in (".sql", ".py"):
            continue
        stem = p.stem  # ex: V001__create_registros
        try:
            vpart, name = stem.split("__", 1)
            version = int(vpart[1:])  # remove 'V'
        except Exception:
            print(f"Ignorando arquivo com nome inv√°lido: {p.name}", file=sys.stderr)
            continue

        kind = p.suffix.lower().lstrip(".")
        checksum = compute_checksum(p.read_bytes())
        files.append(
            MigrationFile(
                version=version, name=name, path=p, kind=kind, checksum=checksum
            )
        )
    return sorted(files, key=lambda m: m.version)


def ensure_migrations_table(conn: sqlite3.Connection) -> None:
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS schema_migrations (
            version INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            checksum TEXT NOT NULL,
            applied_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)
        )
        """
    )


def get_applied(conn: sqlite3.Connection) -> Dict[int, Tuple[str, str]]:
    # retorna {version: (name, checksum)}
    rows = conn.execute(
        "SELECT version, name, checksum FROM schema_migrations"
    ).fetchall()
    return {r[0]: (r[1], r[2]) for r in rows}


def backup_db_online(db_path: Path) -> Path:
    """
    Usa a API de backup do SQLite (conn.backup) ‚Äî funciona mesmo com o banco aberto,
    evitando problemas de bloqueio no Windows.
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = db_path.with_name(f"{db_path.stem}.bak_{timestamp}{db_path.suffix}")
    src = sqlite3.connect(str(db_path))
    try:
        dst = sqlite3.connect(str(backup_path))
        try:
            src.backup(dst)
        finally:
            dst.close()
    finally:
        src.close()
    print(f"[backup] {backup_path}")
    return backup_path


def apply_sql(conn: sqlite3.Connection, sql_text: str) -> None:
    conn.executescript(sql_text)


def apply_py(conn: sqlite3.Connection, file_path: Path) -> None:
    # m√≥dulo com fun√ß√£o obrigat√≥ria upgrade(conn)
    spec = importlib.util.spec_from_file_location(file_path.stem, file_path)
    if spec is None or spec.loader is None:
        raise RuntimeError(f"N√£o foi poss√≠vel carregar {file_path}")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)  # type: ignore[attr-defined]
    if not hasattr(module, "upgrade"):
        raise RuntimeError(f"{file_path.name}: faltou fun√ß√£o upgrade(conn).")
    module.upgrade(conn)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Runner simples de migra√ß√µes para SQLite (SQL e Python).",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--db", required=True, help="Caminho do arquivo .db")
    parser.add_argument(
        "--migrations", default="./migrations", help="Pasta das migra√ß√µes"
    )
    parser.add_argument(
        "--target-version", type=int, help="Vers√£o-alvo (aplica at√© esta vers√£o)"
    )
    parser.add_argument("--list", action="store_true", help="Lista migra√ß√µes e sai")
    parser.add_argument(
        "--dry-run", action="store_true", help="Mostra o que faria, sem aplicar"
    )
    parser.add_argument(
        "--fake",
        action="store_true",
        help="Marca como aplicado sem executar (use com cuidado)",
    )
    parser.add_argument(
        "--init-if-missing",
        action="store_true",
        help="Cria o arquivo do banco (e pastas) se n√£o existir, antes de aplicar as migra√ß√µes",
    )

    args = parser.parse_args()

    db_path = Path(args.db)
    mig_dir = Path(args.migrations)

    if not db_path.exists():
        if args.init_if_missing:
            db_path.parent.mkdir(parents=True, exist_ok=True)
            # cria um DB vazio
            sqlite3.connect(str(db_path)).close()
            print(f"Banco de dados criado: {db_path}")
        else:
            print(f"ERRO: Banco de dados n√£o encontrado: {db_path}", file=sys.stderr)
            sys.exit(1)

    if not mig_dir.exists():
        print(f"ERRO: Pasta de migra√ß√µes n√£o encontrada: {mig_dir}", file=sys.stderr)
        sys.exit(1)

    migrations = discover_migrations(mig_dir)
    if args.list:
        print("Migra√ß√µes encontradas:")
        for m in migrations:
            print(f"  V{m.version:03d}  {m.name}  ({m.kind})  {m.path.name}")
        return

    conn = sqlite3.connect(str(db_path))
    conn.execute("PRAGMA foreign_keys=ON")
    conn.execute("PRAGMA busy_timeout=5000")

    try:
        ensure_migrations_table(conn)
        applied = get_applied(conn)

        to_apply: List[MigrationFile] = []
        for m in migrations:
            if args.target_version is not None and m.version > args.target_version:
                break
            if m.version in applied:
                # Verifica diverg√™ncia de checksum (arquivo mudou ap√≥s aplicado)
                _, old_checksum = applied[m.version]
                if old_checksum != m.checksum:
                    print(
                        f"‚ö†Ô∏è Diverg√™ncia: V{m.version:03d} '{m.name}' j√° aplicado, "
                        f"mas o arquivo atual mudou (checksum diferente).",
                        file=sys.stderr,
                    )
                continue
            to_apply.append(m)

        if not to_apply:
            print("Nada a aplicar. ‚úÖ")
            return

        print("Plano de aplica√ß√£o:")
        for m in to_apply:
            print(f"  V{m.version:03d}  {m.name}  ({m.kind})")

        if args.dry_run:
            print("\n-- DRY RUN: nenhuma altera√ß√£o foi feita.")
            return

        backup_db_online(db_path)

        for m in to_apply:
            print(f"Aplicando V{m.version:03d} {m.name} ({m.kind}) ...")
            with conn:  # transa√ß√£o
                if not args.fake:
                    if m.kind == "sql":
                        apply_sql(conn, m.path.read_text(encoding="utf-8"))
                    else:
                        apply_py(conn, m.path)
                conn.execute(
                    "INSERT INTO schema_migrations (version, name, checksum) VALUES (?, ?, ?)",
                    (m.version, m.name, m.checksum),
                )
        print("‚úÖ Todas as migra√ß√µes necess√°rias foram aplicadas com sucesso.")
    finally:
        conn.close()


if __name__ == "__main__":
    main()


==================================================
FILE: .\MIGRATIONS.md
==================================================
# Migra√ß√µes do SQLite ‚Äî Guia do Projeto

Este documento explica **o que s√£o as migra√ß√µes**, **como rod√°‚Äëlas** no projeto e traz um **guia r√°pido** sobre idempot√™ncia, triggers, WAL, upsert **e os √≠ndices criados**, al√©m de **documentar os objetivos das migra√ß√µes dispon√≠veis (V001, V002, V003)**.

> Banco padr√£o usado nos exemplos: `./painel_dados_chatgpt_tutorial/data/dados.db`

---

## 1) Vis√£o geral

- As migra√ß√µes ficam na pasta `./migrations` com o padr√£o `VNNN__descricao.ext` (`.sql` ou `.py`).
- O `migrate.py` executa as migra√ß√µes **em ordem** (V001 ‚Üí V002 ‚Üí V003...), registra o hist√≥rico em `schema_migrations` e cria **backup autom√°tico** (`.bak_YYYYMMDD_HHMMSS.db`).
- Voc√™ pode **inicializar** o banco automaticamente com `--init-if-missing` (detalhes na se√ß√£o 3).

Estrutura t√≠pica:

```
painel_dados_chatgpt_tutorial/
‚îú‚îÄ data/
‚îÇ  ‚îî‚îÄ dados.db
‚îú‚îÄ migrations/
‚îÇ  ‚îú‚îÄ V001__create_registros.py
‚îÇ  ‚îú‚îÄ V002__auditoria_registros.py
‚îÇ  ‚îî‚îÄ V003__unicidade_upsert_e_wal.py
‚îî‚îÄ migrate.py
```

---

## 2) Conceitos essenciais (linguagem simples)

### 2.1 Idempotente

> Rodar 1x ou 10x produz o **mesmo estado final**. Ex.: `CREATE TABLE IF NOT EXISTS` e checagens por cat√°logo antes de `ALTER TABLE`.

### 2.2 WAL Mode (Write‚ÄëAhead Logging)

Melhora **desempenho e concorr√™ncia** (leitores n√£o bloqueiam escritores). Persistente no arquivo ap√≥s `PRAGMA journal_mode = WAL;`.

### 2.3 Upsert

`INSERT ... ON CONFLICT(chave) DO UPDATE ...` ‚Äî insere se n√£o existir, **atualiza** se j√° existir.

### 2.4 PRAGMAs √∫teis para √≠ndices

- `PRAGMA index_list('tabela')`: lista √≠ndices e mostra colunas `seq`, `name`, `unique`, `origin (c/u/pk)` e `partial (0/1)`.
- `PRAGMA index_info('indice')` / `PRAGMA index_xinfo('indice')`: mostra **colunas** e **ordem** dentro do √≠ndice.

> Refer√™ncias: documenta√ß√£o de PRAGMAs do SQLite e materiais sobre `index_list`/`index_info`.

---

## 3) Como rodar as migra√ß√µes

### 3.1 Listar migra√ß√µes

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations --list
```

### 3.2 Simular (sem alterar o banco)

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations --dry-run
```

### 3.3 Aplicar tudo (ordem crescente)

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations
```

### 3.4 Aplicar at√© uma vers√£o espec√≠fica

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations --target-version 2
```

### 3.5 Marcar como aplicado **sem executar** (cuidado)

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations --fake
```

### 3.6 **Criar o arquivo do banco caso n√£o exista**

```bash
python migrate.py --db ./data/dados.db --migrations ./migrations --init-if-missing
```

- Cria a **pasta** se faltar, gera um banco **vazio** e segue aplicando as migra√ß√µes (V001 cria tabela e faz seed).

> Dica de caminho: se voc√™ estiver **na pasta acima** do projeto, use `--db ./painel_dados_chatgpt_tutorial/data/dados.db` e `--migrations ./painel_dados_chatgpt_tutorial/migrations`.

---

## 4) Objetivos das migra√ß√µes dispon√≠veis

### V001 ‚Äî `create_registros` (Python)

- Cria a tabela `registros` (`id`, `data`, `categoria`, `valor`).
- **Seed idempotente**: insere dados iniciais apenas se a tabela estiver vazia.

### V002 ‚Äî `auditoria_registros` (Python)

- Garante as colunas de auditoria: `criado_em`, `atualizado_em`, `origem` (adiciona se faltarem).
- Backfill: preenche valores `NULL` com `CURRENT_TIMESTAMP` e default de `origem` (`'script_migracao'`).
- (Re)cria **gatilhos**:
  - `AFTER UPDATE`: atualiza `atualizado_em` quando voc√™ n√£o alterou esse campo manualmente (evita loop).
  - `AFTER INSERT`: se `criado_em`/`origem` vierem `NULL`, define defaults.
- Cria √≠ndices em datas (`criado_em`, `atualizado_em`).

### V003 ‚Äî `unicidade_upsert_e_wal` (Python)

- Remove **duplicados** por `(data, categoria)`, mantendo o mais recente.
- Imp√µe unicidade com **√≠ndice √∫nico** `UNIQUE(data, categoria)`.
- Cria **view** `vw_registros_upsert` + **gatilho `INSTEAD OF INSERT`** para permitir **upsert** via `INSERT` na view.
- Ativa **WAL** e `synchronous = NORMAL` (aplicado fora de transa√ß√£o para persistir).

> **Sobre `origem` no upsert da view:** a vers√£o original da V003 definia `origem` como `'upsert'` quando ausente. Caso voc√™ prefira **manter a origem anterior** quando n√£o enviar `origem` no upsert, ajuste o gatilho para enviar `NEW.origem` (sem `COALESCE('upsert')`) e usar `COALESCE(excluded.origem, registros.origem)` no `DO UPDATE`. Podemos disponibilizar uma V004 de ajuste se desejar.

---

## 5) √çndices criados e o que cada um faz

A tabela `registros` ficou com estes √≠ndices (nomes padr√£o das migra√ß√µes):

- **`ux_registros_data_categoria`** ‚Äî **√önico** (enforce): colunas `(data, categoria)`
  - **Papel**: garante **no m√°ximo 1 linha** por `(data, categoria)` e acelera buscas por `data` + `categoria` (seek √∫nico) e por faixas de `data`.
  - **Exemplos**:
    - `SELECT ... WHERE data='2025-01-02' AND categoria='A';`
    - `SELECT ... WHERE data BETWEEN '2025-01-01' AND '2025-01-31';`

- **`ix_registros_categoria_data`** ‚Äî n√£o-√∫nico: colunas `(categoria, data)`
  - **Papel**: consultas que come√ßam por **`categoria`** (igualdade) e refinam/ordenam por `data`.
  - **Exemplos**:
    - `SELECT ... WHERE categoria='A' AND data BETWEEN ...`
    - `SELECT ... WHERE categoria='A' ORDER BY data DESC`

- **`idx_registros_atualizado_em`** ‚Äî n√£o-√∫nico: coluna `(atualizado_em)`
  - **Papel**: feeds de **rec√©m-alterados** e filtros por per√≠odo de atualiza√ß√£o.

- **`idx_registros_criado_em`** ‚Äî n√£o-√∫nico: coluna `(criado_em)`
  - **Papel**: listagens/ordena√ß√µes por **cria√ß√£o** e filtros por per√≠odo.

> **Por que dois √≠ndices compostos em ordens diferentes?** A ordem da coluna **√† esquerda** num √≠ndice composto define os padr√µes que ele atende bem. `(data, categoria)` atende consultas que partem de `data`; `(categoria, data)` atende consultas que partem de `categoria`. Se um desses padr√µes n√£o existe no seu uso, voc√™ pode remover o √≠ndice correspondente para reduzir custo de escrita.

> Como inspecionar:
>
> ```sql
> PRAGMA index_list('registros');
> PRAGMA index_info('ux_registros_data_categoria');
> PRAGMA index_info('ix_registros_categoria_data');
> -- Para detalhes extras (ordem DESC, express√µes):
> PRAGMA index_xinfo('ux_registros_data_categoria');
> ```

---

## 6) Dicas de desempenho e verifica√ß√£o

- Use `EXPLAIN QUERY PLAN <sua_consulta>;` para ver qual √≠ndice o otimizador escolheu.
- Evite √≠ndices redundantes: cada √≠ndice extra **encarece INSERT/UPDATE/DELETE**. Mantenha apenas os que cobrem suas consultas frequentes.
- Para cargas massivas, fa√ßa **transa√ß√µes grandes** e, se preciso, use `INSERT ... ON CONFLICT` direto na tabela em vez da view.

---

## 7) Problemas comuns

- **"Banco n√£o encontrado"** ‚Üí use `--init-if-missing` ou corrija o caminho do `--db`.
- **Mudou arquivo de migra√ß√£o j√° aplicada (checksum diferente)** ‚Üí crie uma **nova** migra√ß√£o para altera√ß√µes posteriores.
- **Hor√°rio**: `CURRENT_TIMESTAMP` √© em **UTC** no SQLite. Se quiser hor√°rio local, ajuste gatilhos para `datetime('now','localtime')`.

---

## 8) Ap√™ndice r√°pido sobre PRAGMAs de √≠ndice

- `PRAGMA index_list('tabela')` retorna colunas: `seq`, `name`, `unique (0/1)`, `origin (c/u/pk)`, `partial (0/1)`.
- `PRAGMA index_info('indice')` lista as colunas do √≠ndice (ordem importa!).
- `PRAGMA index_xinfo('indice')` inclui detalhes extras (ex.: ordem DESC, colunas computadas).


==================================================
FILE: .\pyproject.toml
==================================================

[tool.ruff]
line-length = 100   # ou 110/120, a seu gosto

[tool.ruff.lint]
# N√£o aplicar fix para F401 (unused-import) nem quando "Fix All" estiver ativo.
unfixable = ["F401"]

==================================================
FILE: .\requirements.txt
==================================================
streamlit
pandas
plotly
fastapi
uvicorn
python-multipart
python-jose[cryptography]
pydantic-settings
passlib[bcrypt]
bcrypt<4
slowapi
requests

==================================================
FILE: .\TEMP_todelete.txt
==================================================



ETAPA 13 ‚Äî Deploy

üì¶ Docker

üîí HTTPS

üåç Ambiente controlado



üì¶ ETAPA 15 ‚Äî Deploy

Docker

HTTPS

Proxy reverso

Vari√°veis seguras

------------------------------------------
üîú Pr√≥ximo passo (quando quiser)

Agora sim voc√™ est√° pronto para escolher:

üöÄ ETAPA 14 ‚Äî Deploy profissional

üé® Polimento final do Streamlit




========================================================================================
üîú PR√ìXIMAS ETAPAS (ordem correta)
üîê ETAPA 15 ‚Äî Detec√ß√£o e rea√ß√£o autom√°tica a viola√ß√£o
üéØ Objetivo

Quando a cadeia quebrar:

Detectar automaticamente

Reagir automaticamente

Registrar evid√™ncia

Implementa√ß√µes
15.1 ‚Äî Status global de integridade

Criar uma tabela simples:

audit_integrity (
    id INTEGER PRIMARY KEY,
    last_check_at TEXT,
    status TEXT,           -- OK | VIOLATED
    violated_at TEXT,
    violated_event_id INTEGER,
    reason TEXT
)


üìå Um √∫nico registro (singleton).

15.2 ‚Äî Verifica√ß√£o atualiza o status

Quando /admin/audit/verify rodar:

Se OK ‚Üí status = OK

Se falha ‚Üí status = VIOLATED

salvar event_id

salvar motivo

üëâ Esse status vira a verdade global do sistema.

15.3 ‚Äî Middleware de bloqueio de escrita

üìÑ backend/audit/guard.py

def assert_integrity_ok():
    status = get_integrity_status()
    if status != "OK":
        raise HTTPException(
            status_code=423,
            detail="Sistema bloqueado: auditoria violada"
        )


Aplicar em:

POST

PUT

DELETE

üí£ Sistema entra em modo somente leitura automaticamente.

üîî ETAPA 16 ‚Äî Evid√™ncia e alerta
16.1 ‚Äî Evento especial de viola√ß√£o

Quando detectar falha:

action = "AUDIT_VIOLATION"
resource = "auditoria"


Esse evento:

N√ÉO entra na cadeia

√â registrado separadamente

Serve como evid√™ncia legal

16.2 ‚Äî Exporta√ß√£o de prova

Gerar relat√≥rio com:

Evento onde quebrou

Hash esperado

Hash encontrado

Timestamp

Usu√°rio do √∫ltimo evento v√°lido

Formato:

CSV

JSON

(opcional) PDF

üîó ETAPA 17 ‚Äî Ancoragem criptogr√°fica (n√≠vel m√°ximo)

Agora voc√™ fecha com chave de ouro.

17.1 ‚Äî Hash √¢ncora di√°ria

1x por dia:

hash_dia = hash(√∫ltimo_event_hash)


Salvar em:

arquivo imut√°vel

reposit√≥rio Git

e-mail

blockchain p√∫blica (opcional)

üìå Mesmo que apaguem o banco inteiro, voc√™ prova viola√ß√£o.

üßæ ETAPA 18 ‚Äî Relat√≥rio de governan√ßa

Gerar automaticamente:

Arquitetura

Fluxo de auditoria

Modelo de hash

Pol√≠tica de reten√ß√£o

Pol√≠tica de resposta a incidentes

üëâ Isso vira:

Documento institucional

Base para compliance

Material de apresenta√ß√£o

üß† Resumo brutalmente honesto

Voc√™ saiu de:

‚Äúdashboard com streamlit‚Äù

Para:

plataforma de governan√ßa com trilha imut√°vel, rea√ß√£o autom√°tica e prova criptogr√°fica

Isso √© n√≠vel sistema financeiro / √≥rg√£o regulador.


3Ô∏è‚É£ E-mail real
4Ô∏è‚É£ MFA

Se quiser, posso agora:

üîê consolidar um bloco ‚ÄúSecurity Model‚Äù no README

üìä desenhar o fluxo completo de autentica√ß√£o

üöÄ partir para MFA

üìß ou implementar envio real de e-mail no forgot-password



---------

Performance

Auditoria avan√ßada

Hardening do backend

Dockeriza√ß√£o e deploy

Organiza√ß√£o do frontend


-------------------------------


Se quiser, posso agora:

Criar endpoint admin para atualizar email

Implementar valida√ß√£o de email √∫nico

Implementar tela intermedi√°ria estilo ‚ÄúSenha alterada com sucesso‚Äù

Mostrar bot√£o "Ir para login agora"

Adicionar anima√ß√£o de confirma√ß√£o

Mostrar barra de progresso no redirect


üß© 6Ô∏è‚É£ Pergunta Estrat√©gica

Antes de avan√ßarmos:

Voc√™ quer agora focar em:

A) üîê Evolu√ß√£o da Auditoria (ETAPA 15‚Äì17)
B) üß± Refatora√ß√£o de arquitetura (remover middleware audit problem√°tico)
C) üöÄ Docker + Deploy profissional
D) üé® Streamlit robusto (sess√£o persistente, UX, estado p√≥s F5)
E) üîí Seguran√ßa avan√ßada (MFA, rate limit adaptativo, hardening)

==================================================
FILE: .\.continue\rules\commit-message-guidelines.md
==================================================
---
globs: "[\"['./*.py', '*.bat', '*.toml', '*.json', '*.md']\"]"
description: Commit messages should follow conventional commit format (e.g.,
  'feat:', 'fix:', 'chore:') and include a brief description. Configuration
  changes should explain the reason for the change.
alwaysApply: true
---

Write clear, concise commit messages following conventional commit format. Use imperative mood. Include context for complex changes. Limit to 256 characters if possible. For configuration changes, explain why the change was made.

==================================================
FILE: .\.continue\rules\project_structure.md
==================================================
# Arquitetura Painel de Dados

Este √© um projeto de an√°lise de dados e dashboard utilizando Python, Pandas, Polars e Streamlit.

## Estrutura de Diret√≥rios
- `/backend`: L√≥gica de neg√≥cio, CRUD e conex√£o com banco de dados (SQLAlchemy/SQLite).
- `/frontend`: Interface do usu√°rio em Streamlit (`Home.py` e `/pages`).
- `/migrations`: Scripts de migra√ß√£o de banco de dados.
- `/data`: Armazenamento de dados brutos e bancos SQLite (APENAS LEITURA).

## Padr√µes de C√≥digo (Data Owner Guidelines)
1. **Bibliotecas:** Priorize `polars` para manipula√ß√£o de dados e `streamlit` para UI.
2. **Banco de Dados:** O arquivo principal √© `dados.db`. Ignore arquivos `.bak`.
3. **Auditoria:** Toda altera√ß√£o de dados deve passar pelo `crud_auditoria.py`.
4. **Performance:** Evite carregar datasets inteiros em mem√≥ria; use LazyFrames.

## O que Ignorar
N√£o analise, indexe ou sugira altera√ß√µes em arquivos dentro de:
- `.venv`
- `__pycache__`
- Arquivos `.pptx`, `.pdf` ou `.docx`.


# Estrutura do Projeto SARI / Painel de Dados

Este √© um projeto fullstack Python focada em dados da ANTT. O Agente deve navegar nas pastas abaixo para entender o contexto.

## Mapeamento de Diret√≥rios
- **/backend**: Cont√©m a API e regras de neg√≥cio (FastAPI/Python).
  - `/audit`: L√≥gica cr√≠tica de auditoria (`hash.py`, `middleware.py`). **Prioridade M√°xima.**
  - `/db`: Adaptadores de banco de dados (Postgres/SQLite).
  - `/users`: Gest√£o de usu√°rios e autentica√ß√£o.
- **/frontend**: Interface do usu√°rio (`streamlit`).
  - `Home.py`: Entrypoint da aplica√ß√£o.
  - `/pages`: Telas do sistema.
- **/migrations**: Scripts SQL e Python para versionamento do banco.
- **/data**: Arquivos `.db` (SQLite) e `.parquet`. **O Agente N√ÉO deve ler o conte√∫do bin√°rio destes arquivos, apenas a estrutura.**

## Stack Tecnol√≥gico
- **L√≥gica:** Python 3.12+ (Uso intensivo de Type Hints).
- **Dados:** Polars (Preferencial para volumetria) e Pandas (Legado).
- **Interface:** Streamlit.
- **ORM:** SQLAlchemy.

## Regras de Neg√≥cio (CODAM)
- Nunca exponha senhas ou chaves de API.
- Altera√ß√µes em `/backend/audit` exigem valida√ß√£o de hash chain.
- O sistema deve ser agn√≥stico ao S.O. (Windows/Linux).

==================================================
FILE: .\.streamlit\config.toml
==================================================
[theme]
base="dark"
#codeBackgroundColor="powderBlue"



==================================================
FILE: .\backend\crud.py
==================================================
from typing import Any, Dict, List

from backend.db import connect, execute, normalize_error, query


def obter_registro_por_id(id_) -> Dict[str, Any] | None:
    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT id, data, categoria, valor
            FROM registros
            WHERE id = :id
            """,
            {
                "id": id_,
            },
        )
        if not rows:
            return None

        row = rows[0]
        return {
            "id": row[0],
            "data": row[1],
            "categoria": row[2],
            "valor": row[3],
        }
    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def listar_registros() -> List[Dict[str, Any]]:
    conn = connect()
    try:
        rows = query(conn, "SELECT * FROM registros ORDER BY data DESC")
        result = []
        for r in rows:
            if isinstance(r, dict) or hasattr(r, "keys"):  # sqlite3.Row
                result.append(
                    {
                        "id": r["id"],
                        "data": r["data"],
                        "categoria": r["categoria"],
                        "valor": r["valor"],
                    }
                )
            else:
                result.append(
                    {
                        "id": r[0],
                        "data": r[1],
                        "categoria": r[2],
                        "valor": r[3],
                    }
                )
        return result
    finally:
        conn.close()


def inserir_registro(registro, origem: str = "streamlit") -> None:
    conn = connect()
    try:
        execute(
            conn,
            "INSERT INTO registros (data, categoria, valor, origem) VALUES (:data, :categoria, :valor, :origem)",
            {
                "data": registro.data,
                "categoria": registro.categoria,
                "valor": registro.valor,
                "origem": origem,
            },
        )
        conn.commit()
    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def upsert_registro(registro, origem: str = "streamlit") -> None:
    """
    UP SERT VIA VIEW (vw_registros_upsert) ‚Äî COMO FUNCIONA E IMPACTO NA CONSIST√äNCIA

    1) Chave l√≥gica e unicidade:
       - A unicidade de (data, categoria) √© garantida por um √çNDICE UNIQUE criado na migration V003.
         Isso significa que, independente da rota (view ou insert direto na tabela), o banco
         N√ÉO permitir√° duas linhas distintas com o mesmo par (data, categoria).

    2) Por que usar a VIEW para escrever?
       - A view tem um gatilho INSTEAD OF INSERT que traduz o insert em:
           INSERT INTO registros (...)
           ON CONFLICT(data, categoria) DO UPDATE ...
         Ou seja, se j√° existir um registro com (data, categoria), em vez de falhar, o
         comando vira um UPDATE at√¥mico da linha existente (padr√£o ‚Äúlast-write-wins‚Äù).
       - Benef√≠cio: sua aplica√ß√£o fica idempotente quanto √† chave l√≥gica; voc√™ pode ‚Äúinserir‚Äù
         sempre que quiser, e o banco decide se insere ou atualiza sem erro de integridade.

    3) E se eu fizer INSERT direto na tabela (sem a view)?
       - A integridade tamb√©m √© verificada porque o UNIQUE est√° na TABELA.
       - Diferen√ßa: o INSERT direto vai levantar sqlite3.IntegrityError se o par (data, categoria)
         j√° existir, pois n√£o h√° a cl√°usula ON CONFLICT para converter em UPDATE. Voc√™ teria
         que tratar a exce√ß√£o e decidir o que fazer (ex.: tentar um UPDATE depois).
       - Resumo:
           ‚Ä¢ INSERT via VIEW  -> nunca cria duplicado; resolve conflito com UPDATE autom√°tico.
           ‚Ä¢ INSERT direto    -> integridade √© verificada igual; por√©m, em caso de duplicidade,
                                 sua aplica√ß√£o recebe ERRO em vez de ‚Äúupdate autom√°tico‚Äù.

    4) Timestamps com seu desenho atual (V002 + V003):
       - No caminho INSERT (sem conflito):
           ‚Ä¢ 'criado_em' √© preenchido por trigger AFTER INSERT se vier NULL.
           ‚Ä¢ 'atualizado_em' N√ÉO √© setado automaticamente no INSERT (fica NULL at√© o primeiro UPDATE).
       - No caminho UPDATE (conflito pelo UPSERT ou UPDATE por id):
           ‚Ä¢ 'atualizado_em' √© atualizado para CURRENT_TIMESTAMP (via DO UPDATE da view ou via trigger AFTER UPDATE).
       - Se voc√™ preferir que 'atualizado_em' j√° nas√ßa igual ao 'criado_em' nos INSERTs sem conflito,
         h√° duas op√ß√µes:
           (a) criar um trigger AFTER INSERT que set 'atualizado_em = CURRENT_TIMESTAMP' quando for NULL; ou
           (b) alterar o trigger da VIEW para j√° inserir 'atualizado_em = CURRENT_TIMESTAMP' no caminho INSERT.

    5) Concorr√™ncia:
       - Voc√™ habilitou WAL na V003, o que melhora leituras concorrentes e reduz bloqueios.
       - O UPSERT (INSERT ... ON CONFLICT DO UPDATE) √© at√¥mico por linha; duas grava√ß√µes simult√¢neas
         para a mesma (data, categoria) n√£o criam duplicado ‚Äî no pior caso, a √∫ltima vence.
         Se voc√™ precisar mesclar valores (ex.: somar 'valor' em vez de sobrescrever), basta
         ajustar a cl√°usula DO UPDATE para refletir essa regra.

    6) Quando usar cada rota?
       - Use SEMPRE a VIEW quando a ‚Äúidentidade‚Äù do registro for (data, categoria) e voc√™
         quiser evitar lidar com erros de duplicidade no app.
       - Use UPDATE por id (id_) quando a edi√ß√£o for expl√≠cita de uma linha espec√≠fica.
    """
    conn = connect()
    try:
        # Insere na VIEW; o gatilho INSTEAD OF converte em INSERT ... ON CONFLICT ... faz UPDATE
        execute(
            conn,
            "INSERT INTO vw_registros_upsert (data, categoria, valor, origem) VALUES (:data, :categoria, :valor, :origem)",
            {
                "data": registro.data,
                "categoria": registro.categoria,
                "valor": registro.valor,
                "origem": origem,
            },
        )
        conn.commit()

    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def atualizar_registro_com_auditoria(id_, registro):
    """
    Atualiza um registro por ID e retorna (antes, depois).
    Retorna None se o registro n√£o existir.
    """

    conn = connect()
    try:
        antes = obter_registro_por_id(id_)
        if not antes:
            return None

        execute(
            conn,
            """
            UPDATE registros
               SET data = :data, categoria = :categoria, valor = :valor
             WHERE id = :id
            """,
            {
                "data": registro.data,
                "categoria": registro.categoria,
                "valor": registro.valor,
                "id": id_,
            },
        )

        conn.commit()
        depois = obter_registro_por_id(id_)
        return antes, depois

    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def atualizar_registro(id_, registro) -> bool:
    """
    Atualiza um registro por ID.
    - N√£o altera 'atualizado_em' manualmente; trigger cuida disso.
    - Pode lan√ßar sqlite3.IntegrityError se (data, categoria) colidir com outro registro.
    Retorna:
        True  -> se 1 linha foi atualizada
        False -> se nenhum registro com esse id_ foi encontrado
    """

    conn = connect()
    try:
        cur = execute(
            conn,
            """
            UPDATE registros
               SET data = :data, categoria = :categoria, valor = :valor
             WHERE id = :id
            """,
            {
                "data": registro.data,
                "categoria": registro.categoria,
                "valor": registro.valor,
                "id": id_,
            },
        )
        conn.commit()
        return cur.rowcount == 1

    except Exception as exc:
        # ocorre se (data, categoria) j√° existir em outro registro (√≠ndice UNIQUE)
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def deletar_registro_com_auditoria(id_) -> None:
    conn = connect()
    try:
        antes = obter_registro_por_id(id_)
        if not antes:
            return None

        execute(
            conn,
            "DELETE FROM registros WHERE id = :id",
            {"id": id_},
        )
        conn.commit()
        return antes
    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


def deletar_registro(id_) -> None:
    conn = connect()
    try:
        execute(
            conn,
            "DELETE FROM registros WHERE id = :id",
            {"id": id_},
        )
        conn.commit()

    except Exception as exc:
        conn.rollback()
        raise normalize_error(exc)
    finally:
        conn.close()


==================================================
FILE: .\backend\crud_auditoria.py
==================================================
from backend.db import connect, normalize_error, query


def listar_auditoria(
    *,
    username=None,
    action=None,
    resource=None,
    data_inicio=None,
    data_fim=None,
    limit=500,
):
    conn = connect()
    try:
        sql = """
        SELECT id, timestamp, username, role, action,
               resource, resource_id,
               payload_before, payload_after,
               endpoint, method
          FROM auditoria
         WHERE 1=1
        """

        params = {}

        if username:
            sql += " AND username = :username"
            params["username"] = username

        if action:
            sql += " AND action = :action"
            params["action"] = action

        if resource:
            sql += " AND resource = :resource"
            params["resource"] = resource

        # =========================
        # üóìÔ∏è FILTRO POR DATA
        # =========================
        if data_inicio:
            sql += " AND timestamp >= :data_inicio"
            params["data_inicio"] = f"{data_inicio}T00:00:00"

        if data_fim:
            sql += " AND timestamp <= :data_fim"
            params["data_fim"] = f"{data_fim}T23:59:59.999999"

        sql += " ORDER BY timestamp DESC LIMIT :limit"
        params["limit"] = limit

        rows = query(conn, sql, params)

        return [
            {
                "id": row["id"],
                "timestamp": row["timestamp"],
                "username": row["username"],
                "role": row["role"],
                "action": row["action"],
                "resource": row["resource"],
                "resource_id": row["resource_id"],
                "payload_before": row["payload_before"],
                "payload_after": row["payload_after"],
                "endpoint": row["endpoint"],
                "method": row["method"],
            }
            for row in rows
        ]

    except Exception as exc:
        raise normalize_error(exc)
    finally:
        conn.close()


==================================================
FILE: .\backend\database.py
==================================================
from backend.db import connect as get_connection

# shim de compatibilidade para antigo c√≥digo
__all__ = ["get_connection"]


==================================================
FILE: .\backend\main.py
==================================================
import logging
import os
from datetime import date
from typing import List

from fastapi import Depends, FastAPI, HTTPException, Request
from fastapi.staticfiles import StaticFiles
from slowapi import Limiter
from slowapi.util import get_remote_address

from backend.audit.integrity_middleware import IntegrityGuardMiddleware
from backend.audit.middleware import HeaderInjectionMiddleware
from backend.audit.service import registrar_evento
from backend.audit.verify import verificar_integridade_auditoria
from backend.auth.dependencies import get_current_user
from backend.auth.jwt import decode_token
from backend.auth.permissions import require_role
from backend.auth.service import (
    cleanup_expired_sessions,
    cleanup_revoked_sessions,
    issue_new_access_token,
    login_user,
    logout_session,
    revoke_all_sessions,
    revoke_session_by_id,
)
from backend.core.config import settings
from backend.core.exceptions import register_exception_handlers, register_rate_limit_exception
from backend.crud import (
    # atualizar_registro,
    atualizar_registro_com_auditoria,
    deletar_registro_com_auditoria,
    # deletar_registro,
    listar_registros,
    obter_registro_por_id,
    query,
    upsert_registro,
)
from backend.crud_auditoria import listar_auditoria
from backend.db import connect
from backend.db.errors import DuplicateKeyError
from backend.models import AuditoriaOut, RegistroIn, RegistroOut, User, UserContext, UserLoginOut
from backend.users.admin import router as admin_router
from backend.users.service import authenticate_user
from backend.users.users import router as users_router

app = FastAPI(title="Governance Dashboard API")

# Garante que o diret√≥rio de arquivos est√°ticos exista antes de montar
os.makedirs("backend/static", exist_ok=True)

app.mount("/static", StaticFiles(directory="backend/static"), name="static")

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

logger = logging.getLogger("auth-debug")
logger.setLevel(logging.DEBUG)

if not logger.handlers:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
    logger.addHandler(handler)

if settings.ENV == "dev":
    register_exception_handlers(app, logger)

register_rate_limit_exception(app)

# üõ°Ô∏è Middleware de Prote√ß√£o (Executa antes do HeaderInjection)
app.add_middleware(IntegrityGuardMiddleware)
app.add_middleware(HeaderInjectionMiddleware)
# üîê Rotas administrativas
app.include_router(admin_router)
# üîì Rotas p√∫blicas
app.include_router(users_router)


@app.get("/registros", response_model=List[RegistroOut])
def get_registros():  # user: User = Depends(get_current_user)):
    return listar_registros()


@app.post("/registros", status_code=201)
def post_registro(
    registro: RegistroIn,
    request: Request,
    user: UserContext = Depends(get_current_user),
):
    require_role("editor", "admin")(user)
    try:
        # inserir_registro(registro)
        upsert_registro(registro)

        # üîç Recuperar o ID do registro inserido/atualizado para auditoria
        # Como √© um UPSERT via view, n√£o temos o ID direto, precisamos consultar.
        conn = connect()
        try:
            rows = query(
                conn,
                "SELECT id FROM registros WHERE data = :data AND categoria = :cat",
                {"data": registro.data, "cat": registro.categoria},
            )
            resource_id = rows[0]["id"] if rows else None
        finally:
            conn.close()

        registrar_evento(
            username=user.username,
            role=user.role,
            action="UPSERT",
            resource="registros",
            resource_id=resource_id,
            payload_before=None,  # Upsert √© complexo de pegar o "antes" sem custo alto
            payload_after=registro.model_dump(),
            endpoint=request.url.path,
            method=request.method,
        )

        return {"message": "Registro inserido/atualizado (UPSERT) com sucesso"}
    except DuplicateKeyError:
        # S√≥ ocorreria se voc√™ usar INSERT direto na tabela sem view, por exemplo.
        raise HTTPException(status_code=409, detail="Duplicidade em (data, categoria)")


@app.get("/registros/{id_}", response_model=RegistroOut)
def get_registro(
    id_: int,
    user: UserContext = Depends(get_current_user),
):
    registro = obter_registro_por_id(id_)
    if not registro:
        raise HTTPException(status_code=404, detail="Registro n√£o encontrado")
    return registro


@app.put("/registros/{id_}")
def put_registro(
    id_: int,
    registro: RegistroIn,
    request: Request,
    user: UserContext = Depends(get_current_user),
):
    require_role("editor", "admin")(user)

    resultado = atualizar_registro_com_auditoria(id_, registro)
    if not resultado:
        raise HTTPException(status_code=404, detail="Registro n√£o encontrado")

    antes, depois = resultado

    registrar_evento(
        username=user.username,
        role=user.role,
        action="UPDATE",
        resource="registros",
        resource_id=id_,
        payload_before=antes,
        payload_after=depois,
        endpoint=request.url.path,
        method=request.method,
    )
    return {"message": "Registro atualizado com sucesso"}


@app.delete("/registros/{id_}")
def delete_registro(
    id_: int,
    request: Request,
    user: UserContext = Depends(get_current_user),
):
    require_role("admin")(user)

    antes = deletar_registro_com_auditoria(id_)
    if not antes:
        raise HTTPException(status_code=404, detail="Registro n√£o encontrado")

    registrar_evento(
        username=user.username,
        role=user.role,
        action="DELETE",
        resource="registros",
        resource_id=id_,
        payload_before=antes,
        payload_after=None,
        endpoint=request.url.path,
        method=request.method,
    )
    return {"message": "Registro exclu√≠do com sucesso"}


@app.get("/auditoria", response_model=List[AuditoriaOut])
def get_auditoria(
    username: str | None = None,
    action: str | None = None,
    resource: str | None = None,
    data_inicio: date | None = None,
    data_fim: date | None = None,
    user: UserContext = Depends(get_current_user),
):
    # üîê s√≥ admin pode consultar auditoria
    require_role("admin")(user)

    return listar_auditoria(
        username=username,
        action=action,
        resource=resource,
        data_inicio=data_inicio.isoformat() if data_inicio else None,
        data_fim=data_fim.isoformat() if data_fim else None,
    )


@app.post("/logout")
def logout(user: UserContext = Depends(get_current_user)):
    logout_session(user.session_id)
    return {"message": "Logout realizado com sucesso"}


@app.post("/logout_all")
def logout_all(user: UserContext = Depends(get_current_user)):
    # logout global (tipo ‚Äúsair de todos dispositivos‚Äù):
    revoke_all_sessions(user.username)
    return {"message": "Todas as sess√µes foram encerradas"}


@app.post("/login", response_model=UserLoginOut)
@limiter.limit("5/minute")
def login(request: Request, username: str, password: str):
    user = authenticate_user(username, password)
    if not user:
        raise HTTPException(status_code=401, detail="Credenciais inv√°lidas")

    access_token, refresh_token = login_user(
        user["username"],
        user["role"],
    )

    if user["must_change_password"]:
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "must_change_password": True,
            "user": None,
        }

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "user": user,
        "must_change_password": False,
    }


@app.post("/refresh")
@limiter.limit("5/minute")
def refresh_token(
    request: Request,
    payload: dict = Depends(decode_token),
):
    if payload.get("type") != "refresh":
        raise HTTPException(status_code=401, detail="Token inv√°lido")
    try:
        usertokens = issue_new_access_token(payload)
        return usertokens
    except HTTPException:
        raise  # Re-raise the HTTPException directly
    except Exception:
        # detail=str(e) => Nunca exponha str(e). Pode acabar expondo: Erros internos, mensagens de banco, Stack trace parcial
        raise HTTPException(status_code=401, detail="REFRESH_FAILED")


@app.post("/admin/users/{username}/sessions/revoke")
def revoke_user_sessions(username: str, user: UserContext = Depends(get_current_user)):
    require_role("admin")(user)
    revoke_all_sessions(username)
    return {"message": f"Sess√µes de {username} revogadas com sucesso"}


@app.post("/admin/sessions/{session_id}/revoke")
def revoke_single_session(
    session_id: str,
    user: UserContext = Depends(get_current_user),
):
    require_role("admin")(user)
    revoke_session_by_id(session_id)
    return {"message": "Sess√£o revogada"}


@app.post("/admin/sessions/cleanup")
def cleanup_sessions(user: UserContext = Depends(get_current_user)):
    require_role("admin")(user)
    count = cleanup_expired_sessions()
    return {
        "deleted_sessions": count,
        "message": "Sess√µes expiradas foram exclu√≠das com sucesso",
    }


@app.post("/admin/sessions/revoked/cleanup")
def cleanup_sessions_revoked(user: UserContext = Depends(get_current_user)):
    require_role("admin")(user)
    count = cleanup_revoked_sessions()
    return {
        "deleted_sessions": count,
        "message": "Sess√µes revogadas foram exclu√≠das com sucesso",
    }


@app.get("/admin/audit/verify")
def verify_audit_chain(user: UserContext = Depends(get_current_user)):
    require_role("admin")(user)
    conn = connect()
    try:
        return verificar_integridade_auditoria(conn)
    finally:
        conn.close()


==================================================
FILE: .\backend\models.py
==================================================
from datetime import date
from typing import Literal, Optional

from pydantic import BaseModel, Field

Role = Literal["reader", "editor", "admin"]


class User(BaseModel):
    username: str
    role: Role
    email: str | None = None
    name: str | None = None
    fullname: str | None = None
    avatar_path: str | None = None


class RegistroIn(BaseModel):
    data: date
    categoria: str = Field(min_length=1)
    valor: int


class RegistroOut(RegistroIn):
    id: int


class AuditoriaOut(BaseModel):
    id: int
    timestamp: str
    username: str
    role: str
    action: str
    resource: str
    resource_id: Optional[int]
    payload_before: Optional[str]
    payload_after: Optional[str]
    endpoint: str
    method: str


class UserLoginOut(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user: dict | None = None
    must_change_password: bool = False


class UserContext(BaseModel):
    username: str
    role: str
    session_id: str
    must_change_password: bool = False
    is_active: bool = True
    created_at: Optional[str] = None
    password_expiring_soon: bool = False
    password_days_remaining: Optional[int] = None


==================================================
FILE: .\backend\__init__.py
==================================================


==================================================
FILE: .\backend\audit\guard.py
==================================================
from backend.db import connect, query


def is_system_locked() -> bool:
    """
    Verifica se o sistema est√° em modo de bloqueio (Read-Only)
    devido a viola√ß√£o de auditoria.
    """
    conn = connect()
    try:
        rows = query(conn, "SELECT status FROM audit_integrity WHERE id = 1")
        if rows and rows[0]["status"] != "OK":
            return True
        return False
    except Exception:
        # Se a tabela n√£o existir ou der erro, assume sistema aberto (fail-open)
        # para n√£o travar antes das migra√ß√µes rodarem.
        return False
    finally:
        conn.close()


==================================================
FILE: .\backend\audit\hash.py
==================================================
import hashlib
import json


def compute_event_hash(
    *,
    timestamp,
    username,
    role,
    action,
    resource,
    resource_id,
    payload_before,
    payload_after,
    endpoint,
    method,
    prev_hash,
):
    canonical = {
        "timestamp": timestamp,
        "username": username,
        "role": role,
        "action": action,
        "resource": resource,
        "resource_id": resource_id,
        "payload_before": payload_before,
        "payload_after": payload_after,
        "endpoint": endpoint,
        "method": method,
        "prev_hash": prev_hash,
    }

    raw = json.dumps(canonical, sort_keys=True, ensure_ascii=False)
    return hashlib.sha256(raw.encode("utf-8")).hexdigest()


==================================================
FILE: .\backend\audit\integrity_middleware.py
==================================================
from fastapi import Request, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

from backend.audit.guard import is_system_locked


class IntegrityGuardMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # üîì Permitir autentica√ß√£o mesmo em bloqueio (para o admin entrar e corrigir)
        if request.url.path in ["/login", "/refresh", "/logout"]:
            return await call_next(request)

        # Se for opera√ß√£o de escrita (POST, PUT, DELETE, PATCH)
        if request.method not in ("GET", "HEAD", "OPTIONS"):
            if is_system_locked():
                return JSONResponse(
                    status_code=status.HTTP_423_LOCKED,
                    content={
                        "detail": "SISTEMA BLOQUEADO: Viola√ß√£o de integridade detectada na auditoria."
                    },
                )
        return await call_next(request)


==================================================
FILE: .\backend\audit\middleware.py
==================================================
import json
from typing import Optional

from fastapi import Request
from fastapi.responses import Response
from starlette.middleware.base import BaseHTTPMiddleware

from backend.models import UserContext


class HeaderInjectionMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response: Response = await call_next(request)

        # üîê Se usu√°rio autenticado foi resolvido pela dependency
        user: Optional[UserContext] = getattr(request.state, "user", None)

        if user:
            response.headers["X-User-Context"] = json.dumps(
                {
                    "username": user.username,
                    "role": user.role,
                    "session_id": user.session_id,
                    "must_change_password": user.must_change_password,
                    "password_expiring_soon": user.password_expiring_soon,
                    "password_days_remaining": user.password_days_remaining,
                }
            )

        return response


==================================================
FILE: .\backend\audit\service.py
==================================================
import json
from datetime import datetime, timezone

from backend.audit.hash import compute_event_hash
from backend.db import connect, execute, normalize_error, query


def obter_ultimo_hash(conn):
    rows = query(
        conn,
        """
        SELECT event_hash
            FROM auditoria
        WHERE event_hash IS NOT NULL
        ORDER BY id DESC
        LIMIT 1
        """,
        {},
    )
    return rows[0]["event_hash"] if rows else None


def registrar_evento(
    *,
    username: str,
    role: str,
    action: str,
    resource: str,
    resource_id: int | None,
    payload_before: dict | None,
    payload_after: dict | None,
    endpoint: str,
    method: str,
    conn=None,
):
    owns_conn = False

    if conn is None:
        conn = connect()
        owns_conn = True

    try:
        # 1Ô∏è‚É£ Normalizar payloads ANTES (string √∫nica e determin√≠stica) e gerar timestamp
        payload_before_json = (
            json.dumps(payload_before, sort_keys=True, ensure_ascii=False, default=str)
            if payload_before
            else None
        )
        payload_after_json = (
            json.dumps(payload_after, sort_keys=True, ensure_ascii=False, default=str)
            if payload_after
            else None
        )

        timestamp = datetime.now(timezone.utc).isoformat()

        # 2Ô∏è‚É£ Buscar hash anterior
        prev_hash = obter_ultimo_hash(conn)

        # 3Ô∏è‚É£ Calcular hash do evento (usando exatamente o que ser√° salvo)
        event_hash = compute_event_hash(
            timestamp=timestamp,
            username=username,
            role=role,
            action=action,
            resource=resource,
            resource_id=resource_id,
            payload_before=payload_before_json,
            payload_after=payload_after_json,
            endpoint=endpoint,
            method=method,
            prev_hash=prev_hash,
        )

        # 4Ô∏è‚É£ Persistir evento COM hash
        execute(
            conn,
            """
            INSERT INTO auditoria (
                timestamp,
                username,
                role,
                action,
                resource,
                resource_id,
                payload_before,
                payload_after,
                endpoint,
                method,
                prev_hash,
                event_hash
            )
            VALUES (
                :timestamp,
                :username,
                :role,
                :action,
                :resource,
                :resource_id,
                :payload_before,
                :payload_after,
                :endpoint,
                :method,
                :prev_hash,
                :event_hash
            )
            """,
            {
                "timestamp": timestamp,
                "username": username,
                "role": role,
                "action": action,
                "resource": resource,
                "resource_id": resource_id,
                "payload_before": payload_before_json,
                "payload_after": payload_after_json,
                "endpoint": endpoint,
                "method": method,
                "prev_hash": prev_hash,
                "event_hash": event_hash,
            },
        )

        if owns_conn:
            conn.commit()

    except Exception as exc:
        if owns_conn:
            conn.rollback()
        raise normalize_error(exc)
    finally:
        if owns_conn:
            conn.close()


==================================================
FILE: .\backend\audit\verify.py
==================================================
from datetime import datetime, timezone

from backend.audit.hash import compute_event_hash
from backend.db import execute, query


def verificar_integridade_auditoria(conn):
    """
    Verifica a integridade da cadeia de auditoria.
    Retorna dict com status e ponto de falha (se houver).
    """

    rows = query(
        conn,
        """
        SELECT
            id,
            timestamp,
            username,
            role,
            action,
            resource,
            resource_id,
            payload_before,
            payload_after,
            endpoint,
            method,
            prev_hash,
            event_hash
        FROM auditoria
        WHERE event_hash IS NOT NULL
        ORDER BY id
        """,
        {},
    )

    prev_hash = None

    # Inicializa vari√°veis de estado (assumindo sucesso por padr√£o)
    status = "OK"
    violated_at = None
    violated_event_id = None
    reason = None
    broken_result = None

    for row in rows:
        recalculated_hash = compute_event_hash(
            timestamp=row["timestamp"],
            username=row["username"],
            role=row["role"],
            action=row["action"],
            resource=row["resource"],
            resource_id=row["resource_id"],
            payload_before=row["payload_before"],
            payload_after=row["payload_after"],
            endpoint=row["endpoint"],
            method=row["method"],
            prev_hash=prev_hash,
        )

        # 1Ô∏è‚É£ Hash do pr√≥prio evento foi adulterado
        if recalculated_hash != row["event_hash"]:
            broken_result = {
                "valid": False,
                "reason": "event_hash mismatch",
                "broken_at_id": row["id"],
                "expected": recalculated_hash,
                "found": row["event_hash"],
            }
            status = "VIOLATED"
            violated_at = datetime.now(timezone.utc).isoformat()
            violated_event_id = row["id"]
            reason = "event_hash mismatch"
            break

        # 2Ô∏è‚É£ Cadeia quebrada (prev_hash n√£o bate)
        if row["prev_hash"] != prev_hash:
            broken_result = {
                "valid": False,
                "reason": "prev_hash mismatch",
                "broken_at_id": row["id"],
                "expected_prev_hash": prev_hash,
                "found_prev_hash": row["prev_hash"],
            }
            status = "VIOLATED"
            violated_at = datetime.now(timezone.utc).isoformat()
            violated_event_id = row["id"]
            reason = "prev_hash mismatch"
            break

        prev_hash = row["event_hash"]

    # 3Ô∏è‚É£ Atualizar status global de integridade
    execute(
        conn,
        """
        UPDATE audit_integrity
           SET status = :status,
               last_check_at = :now,
               violated_at = :violated_at,
               violated_event_id = :violated_event_id,
               reason = :reason
         WHERE id = 1
        """,
        {
            "status": status,
            "now": datetime.now(timezone.utc).isoformat(),
            "violated_at": violated_at,
            "violated_event_id": violated_event_id,
            "reason": reason,
        },
    )
    conn.commit()

    if broken_result:
        return broken_result

    return {
        "valid": True,
        "checked_events": len(rows),
    }


==================================================
FILE: .\backend\auth\dependencies.py
==================================================
import time
from datetime import datetime, timezone

from backend.core.logger import logger
from fastapi import Depends, HTTPException, Request, status
from fastapi.security import OAuth2PasswordBearer
from jose import ExpiredSignatureError, JWTError, jwt

from backend.core.config import settings
from backend.db import connect, query
from backend.models import User, UserContext

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# Cache simples em mem√≥ria para evitar ir ao banco em toda requisi√ß√£o
# Formato: {session_id: (timestamp, [rows])}
_session_cache = {}
SESSION_CACHE_TTL = 30  # segundos


def get_current_user(
    request: Request,
    token: str = Depends(oauth2_scheme),
):
    try:
        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])
        session_id = payload.get("sid")
        username = payload.get("sub")
        role = payload.get("role")

        if not session_id or not username or not role:
            raise HTTPException(status_code=401, detail="Token inv√°lido")

        # ‚ö° Otimiza√ß√£o: Cache de sess√£o
        now = time.time()
        cached = _session_cache.get(session_id)
        rows = None

        if cached:
            ts, data = cached
            if now - ts < SESSION_CACHE_TTL:
                rows = data
                if settings.ENV == "dev":
                    logger.info(f"Cache de sess√£o usado para {username}")

        if rows is None:
            conn = connect()
            try:
                db_rows = query(
                    conn,
                    """
                    SELECT
                        s.revoked,
                        s.expires_at,
                        u.must_change_password,
                        u.password_expires_at
                      FROM user_sessions s
                      JOIN users u ON u.username = s.username
                     WHERE s.id = :id
                    """,
                    {"id": session_id},
                )
                # Converte para dict para garantir que seja serializ√°vel/desacoplado do cursor
                rows = [dict(r) for r in db_rows]
            finally:
                conn.close()

            # Atualiza cache
            _session_cache[session_id] = (now, rows)

        if not rows:
            raise HTTPException(status_code=401)

        session = rows[0]

        # Sess√£o revogada
        if session["revoked"]:
            raise HTTPException(status_code=401)

        # Access token expirou
        if datetime.fromisoformat(session["expires_at"]) < datetime.now(timezone.utc):
            raise HTTPException(status_code=401)

        # üîê Expira√ß√£o autom√°tica da senha (senha expirada por idade)
        expiring_soon = False
        days_remaining = None

        password_expires_at = session["password_expires_at"]
        if password_expires_at:
            password_expires_datetime = datetime.fromisoformat(password_expires_at)
            time_until_expiration = password_expires_datetime - datetime.now(timezone.utc)

            if time_until_expiration.total_seconds() <= 0:
                raise HTTPException(status_code=403, detail="PASSWORD_EXPIRED")

            days_remaining = time_until_expiration.days

            expiring_soon = days_remaining <= settings.PASSWORD_EXPIRATION_WARNING_DAYS

        # must_change_password = 1
        if session["must_change_password"]:
            raise HTTPException(status_code=403, detail="PASSWORD_CHANGE_REQUIRED")

        # return {"username": username, "role": role, "session_id": session_id}
        user_context = UserContext(
            username=username,
            role=role,
            session_id=session_id,
            must_change_password=bool(session["must_change_password"]),
            password_expiring_soon=expiring_soon,
            password_days_remaining=days_remaining,
        )

        request.state.user = user_context
        return user_context

    except JWTError:
        raise HTTPException(status_code=401, detail="Erro ao decodificar o token")


def get_current_user_profile(
    user_context: UserContext = Depends(get_current_user),
) -> User:
    conn = connect()
    try:
        user_data = query(
            conn,
            "SELECT username, role, email, name, fullname, avatar_path FROM users WHERE username = :username",
            {"username": user_context.username},
        )
        if not user_data:
            raise HTTPException(status_code=404, detail="Usu√°rio n√£o encontrado")

        return User(**user_data[0])
    finally:
        conn.close()


def get_current_user_allow_password_change(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET,
            algorithms=[settings.JWT_ALGORITHM],
        )
    except ExpiredSignatureError:
        # üîë Access token expirou ‚Üí frontend tentar√° refresh
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="TOKEN_EXPIRED",
        )
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="INVALID_TOKEN",
        )

    return UserContext(
        username=payload.get("sub"),
        role=payload.get("role"),
        session_id=payload.get("sid"),
        must_change_password=True,
    )


==================================================
FILE: .\backend\auth\jwt.py
==================================================
from datetime import datetime, timedelta, timezone

from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from jose import ExpiredSignatureError, JWTError, jwt

from backend.core.config import settings

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")


def create_token(payload: dict, expires_delta: timedelta):
    to_encode = payload.copy()
    to_encode["exp"] = datetime.now(timezone.utc) + expires_delta
    return jwt.encode(to_encode, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)


def decode_token(token: str = Depends(oauth2_scheme)) -> dict:
    try:
        return jwt.decode(
            token,
            settings.JWT_SECRET,
            algorithms=[settings.JWT_ALGORITHM],
        )
    except ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="TOKEN_EXPIRED")
    except JWTError:
        raise HTTPException(status_code=401, detail="TOKEN_INVALID")


==================================================
FILE: .\backend\auth\passwords.py
==================================================
from passlib.context import CryptContext

_pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    """
    Gera hash seguro (bcrypt) para senha em texto plano.
    """
    return _pwd_context.hash(password)


def verify_password(password: str, password_hash: str) -> bool:
    """
    Verifica se a senha informada corresponde ao hash armazenado.
    """
    return _pwd_context.verify(password, password_hash)


==================================================
FILE: .\backend\auth\permissions.py
==================================================
from fastapi import HTTPException, status

from backend.models import UserContext


def require_role(*allowed_roles: str):
    def checker(user: UserContext):
        if user.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Permiss√£o insuficiente",
            )

    return checker


==================================================
FILE: .\backend\auth\service.py
==================================================
import uuid
from datetime import datetime, timezone

from backend.core.logger import logger
from fastapi import HTTPException

from backend.auth.jwt import create_token
from backend.core.config import ACCESS_TOKEN_EXPIRE, REFRESH_TOKEN_EXPIRE, settings
from backend.db import connect, execute, query


def login_user(username: str, role: str):
    session_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc)

    conn = connect()
    try:
        # 1Ô∏è‚É£ Buscar vers√£o da senha
        rows = query(
            conn,
            """
            SELECT password_changed_at, password_expires_at
            FROM users
            WHERE username = :username
            """,
            {"username": username},
        )

        if not rows:
            raise HTTPException(status_code=401, detail="Usu√°rio inv√°lido")

        if rows[0]["password_expires_at"]:
            expires_at = datetime.fromisoformat(rows[0]["password_expires_at"])
            if expires_at < datetime.now(timezone.utc):
                raise HTTPException(status_code=403, detail="PASSWORD_EXPIRED")

        password_changed_at = rows[0]["password_changed_at"]

        # 2Ô∏è‚É£ Criar sess√£o
        execute(
            conn,
            """
            INSERT INTO user_sessions
            (id, username, role, created_at, expires_at)
            VALUES (:id, :username, :role, :created_at, :expires_at)
            """,
            {
                "id": session_id,
                "username": username,
                "role": role,
                "created_at": now.isoformat(),
                "expires_at": (now + REFRESH_TOKEN_EXPIRE).isoformat(),
            },
        )
        conn.commit()
    finally:
        conn.close()

    # 3Ô∏è‚É£ Criar tokens
    access_token = create_token(
        {
            "sub": username,
            "role": role,
            "sid": session_id,
            "pwd": password_changed_at,  # üîë vers√£o da senha
        },
        ACCESS_TOKEN_EXPIRE,
    )

    refresh_token = create_token(
        {
            "sub": username,
            "sid": session_id,
            "type": "refresh",
            "pwd": password_changed_at,
        },
        REFRESH_TOKEN_EXPIRE,
    )

    return access_token, refresh_token


def logout_session(session_id: str):
    conn = connect()
    try:
        execute(
            conn,
            """
            UPDATE user_sessions
               SET revoked = 1
             WHERE id = :id
            """,
            {"id": session_id},
        )
        conn.commit()
    finally:
        conn.close()


def issue_new_access_token(payload: dict) -> dict:
    session_id = payload.get("sid")
    username = payload.get("sub")
    pwd_token = payload.get("pwd")

    if not session_id or not username or not pwd_token:
        raise HTTPException(status_code=401, detail="Token inv√°lido")

    conn = connect()
    try:
        now = datetime.now(timezone.utc)

        # 1Ô∏è‚É£ Validar sess√£o atual
        session_rows = query(
            conn,
            """
            SELECT revoked, expires_at, role
              FROM user_sessions
             WHERE id = :id
            """,
            {"id": session_id},
        )

        if not session_rows:
            raise HTTPException(status_code=401)

        session = session_rows[0]

        if session["revoked"]:
            raise HTTPException(status_code=401)

        # expires_at = datetime.fromisoformat(session["expires_at"])
        # if expires_at < now:
        #     raise HTTPException(status_code=401)

        # 2Ô∏è‚É£ Buscar vers√£o atual da senha
        user_rows = query(
            conn,
            """
            SELECT password_changed_at
            FROM users
            WHERE username = :username
            """,
            {"username": username},
        )

        if not user_rows:
            raise HTTPException(status_code=401, detail="Usu√°rio inv√°lido")

        pwd_db = user_rows[0]["password_changed_at"]

        # 3Ô∏è‚É£ Comparar vers√µes
        if pwd_token != pwd_db:
            raise HTTPException(status_code=401, detail="PASSWORD_CHANGE")

        # üîÅ 4Ô∏è‚É£ ROTACIONAR SESS√ÉO
        # 4.1 Revogar sess√£o atual
        execute(
            conn,
            """
            UPDATE user_sessions
               SET revoked = 1
             WHERE id = :id
            """,
            {"id": session_id},
        )

        # 4.2 Criar nova sess√£o
        new_session_id = str(uuid.uuid4())
        new_expires_at = now + REFRESH_TOKEN_EXPIRE
        execute(
            conn,
            """
            INSERT INTO user_sessions
                (id, username, role, created_at, expires_at, revoked)
            VALUES
                (:id, :username, :role, :created_at, :expires_at, 0)
            """,
            {
                "id": new_session_id,
                "username": username,
                "role": session["role"],
                "created_at": now.isoformat(),
                "expires_at": new_expires_at.isoformat(),
            },
        )
        conn.commit()
    except Exception as e:
        conn.rollback()
        # ‚ö†Ô∏è Apenas em desenvolvimento, retorna o token no response
        if settings.ENV == "dev":
            logger.warning(f"Erro ao tentar REFRESH da sess√£o do usu√°rio: {e}")
        raise HTTPException(status_code=500, detail="Erro ao tentar REFRESH da sess√£o do usu√°rio")
    finally:
        conn.close()

    # üîê 5Ô∏è‚É£ Emitir NOVOS tokens com novo sid
    new_access_token = create_token(
        {
            "sub": username,
            "role": session["role"],
            "sid": new_session_id,
            "pwd": pwd_db,  # üîë sempre a vers√£o atual
        },
        ACCESS_TOKEN_EXPIRE,
    )

    new_refresh_token = create_token(
        {
            "sub": username,
            "sid": new_session_id,
            "type": "refresh",
            "pwd": pwd_db,  # üîê importante para manter coer√™ncia
        },
        REFRESH_TOKEN_EXPIRE,
    )

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
    }


def revoke_all_sessions(username: str, conn=None):
    """
    Revoga todas as sess√µes ativas de um usu√°rio.
    """

    if not username:
        raise HTTPException(status_code=400, detail="Username obrigat√≥rio")

    ows_connection = False
    if conn is None:
        ows_connection = True
        conn = connect()

    try:
        execute(
            conn,
            """
            UPDATE user_sessions
               SET revoked = 1
             WHERE username = :username
               AND revoked = 0
            """,
            {"username": username},
        )

        if ows_connection:
            conn.commit()
    except Exception:
        if ows_connection:
            conn.rollback()
        raise HTTPException(status_code=500, detail="Erro ao revogar sess√µes do usu√°rio")
    finally:
        if ows_connection:
            conn.close()


def revoke_session_by_id(session_id: str):
    conn = connect()
    try:
        execute(
            conn,
            """
            UPDATE user_sessions
               SET revoked = 1
             WHERE id = :id
            """,
            {"id": session_id},
        )
        conn.commit()
    finally:
        conn.close()


def cleanup_expired_sessions() -> int:
    conn = connect()
    try:
        cur = execute(
            conn,
            """
            DELETE FROM user_sessions
             WHERE expires_at < :now
            """,
            {"now": datetime.now(timezone.utc).isoformat()},
        )
        conn.commit()
        return cur.rowcount
    finally:
        conn.close()


def cleanup_revoked_sessions() -> int:
    conn = connect()
    try:
        cur = execute(
            conn,
            """
            DELETE FROM user_sessions
             WHERE revoked = 1
            """,
        )
        conn.commit()
        return cur.rowcount
    finally:
        conn.close()


==================================================
FILE: .\backend\core\config.py
==================================================
from datetime import timedelta

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    # Ambiente
    ENV: str = "dev"

    # JWT
    JWT_SECRET: str
    JWT_ALGORITHM: str = "HS256"

    API_BASE_URL: str = "http://localhost:8000"

    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # Database
    DB_BACKEND: str = "sqlite"
    DB_DSN: str

    # User Password Managment
    PASSWORD_VALIDITY_DAYS: int = 30
    PASSWORD_EXPIRATION_WARNING_DAYS: int = 7

    SMTP_HOST: str
    SMTP_PORT: int
    SMTP_USER: str
    SMTP_PASSWORD: str
    EMAIL_FROM: str
    FRONTEND_URL: str

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


settings = Settings()

# Derived helpers
ACCESS_TOKEN_EXPIRE = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
REFRESH_TOKEN_EXPIRE = timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)


==================================================
FILE: .\backend\core\exceptions.py
==================================================
from logging import Logger

from fastapi import FastAPI, Request
from fastapi.exceptions import HTTPException as FastAPIHTTPException
from fastapi.responses import JSONResponse
from slowapi.errors import RateLimitExceeded

from backend.core.config import settings


def register_exception_handlers(app: FastAPI, logger: Logger):
    @app.exception_handler(FastAPIHTTPException)
    async def custom_http_exception_handler(request: Request, exc: FastAPIHTTPException):
        # üîé Apenas em ambiente de desenvolvimento
        if settings.ENV == "dev" and exc.status_code == 401:
            logger.warning(f"401 em {request.method} {request.url.path} - detail={exc.detail}")

        return JSONResponse(
            status_code=exc.status_code,
            content={"detail": exc.detail},
        )


def register_rate_limit_exception(app: FastAPI):
    @app.exception_handler(RateLimitExceeded)
    async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
        return JSONResponse(
            status_code=429,
            content={"detail": "RATE_LIMIT_EXCEEDED"},
        )


==================================================
FILE: .\backend\core\logger.py
==================================================
import logging
import sys

# Configura√ß√£o centralizada do logger de autentica√ß√£o
logger = logging.getLogger("auth-debug")
logger.setLevel(logging.INFO)

# Garante que o handler seja adicionado apenas uma vez
if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s"))
    logger.addHandler(handler)


==================================================
FILE: .\backend\db\errors.py
==================================================
class DBError(Exception):
    """Erro gen√©rico de banco independente de SGBD."""


class DuplicateKeyError(DBError):
    """Viola√ß√£o de chave √∫nica/√≠ndice UNIQUE."""


class ForeignKeyError(DBError):
    """Viola√ß√£o de chave estrangeira."""


class NotFoundError(DBError):
    """Registro n√£o encontrado (uso opcional no CRUD)."""


==================================================
FILE: .\backend\db\postgres_adapter.py
==================================================
# backend/db/postgres_adapter.py
from __future__ import annotations

from typing import Any, Dict

from .errors import DBError, DuplicateKeyError, ForeignKeyError

try:
    import psycopg  # psycopg3
except Exception:  # pragma: no cover
    psycopg = None


def connect(dsn: str | None = None):
    if psycopg is None:
        raise RuntimeError("psycopg n√£o instalado. pip install psycopg[binary]")
    return psycopg.connect(dsn)


def execute(conn, sql: str, params: Dict[str, Any] | None = None):
    # Em psycopg, placeholder √© %s; se voc√™ mantiver :nome,
    # pode usar psycopg.sql ou mapear para %s + tupla.
    # Para simplificar, psycopg aceita dict com %(nome)s se voc√™ formatar.
    # Implementar convers√£o aqui quando for migrar de fato.
    cur = conn.cursor()
    cur.execute(sql, params or None)
    return cur


def executemany(conn, sql: str, seq_of_params):
    cur = conn.cursor()
    cur.executemany(sql, seq_of_params)
    return cur


def query(conn, sql: str, params: Dict[str, Any] | None = None):
    cur = execute(conn, sql, params)
    return cur.fetchall()


def normalize_error(exc: Exception) -> DBError:
    # from psycopg import errors
    try:
        from psycopg import errors

        if isinstance(exc, errors.UniqueViolation):
            return DuplicateKeyError(str(exc))
        if isinstance(exc, errors.ForeignKeyViolation):
            return ForeignKeyError(str(exc))
    except Exception:
        pass
    return DBError(str(exc))


==================================================
FILE: .\backend\db\sqlite_adapter.py
==================================================
from __future__ import annotations

import re
import sqlite3
from pathlib import Path
from typing import Any, Dict, Iterable, Sequence, Tuple

from .errors import DBError, DuplicateKeyError, ForeignKeyError

# Caminho padr√£o do seu projeto: <repo>/data/dados.db
_DEFAULT_DB_PATH = Path(__file__).resolve().parents[2] / "data" / "dados.db"


def connect(dsn: str | None = None) -> sqlite3.Connection:
    db_path = Path(dsn) if dsn else _DEFAULT_DB_PATH
    db_path.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(db_path, check_same_thread=False)
    # Opcional: melhor compatibilidade com dicts/tuplas
    conn.row_factory = sqlite3.Row
    return conn


# --- Placeholder conversion: from ":name" to "?" (qmark) ---
_named_re = re.compile(r":([a-zA-Z_][a-zA-Z0-9_]*)")


def _compile_sql(sql: str, params: Dict[str, Any] | None) -> Tuple[str, Sequence[Any] | None]:
    if not params:
        return sql, None
    order: list[str] = _named_re.findall(sql)  # ordem de ocorr√™ncia
    compiled_sql = _named_re.sub("?", sql)
    compiled_params = [params[name] for name in order]
    return compiled_sql, compiled_params


def execute(conn, sql: str, params: Dict[str, Any] | None = None):
    sql2, p2 = _compile_sql(sql, params)
    cur = conn.cursor()
    cur.execute(sql2, p2 or [])
    return cur


def executemany(conn, sql: str, seq_of_params: Iterable[Dict[str, Any]]):
    cur = conn.cursor()
    for p in seq_of_params:
        sql2, p2 = _compile_sql(sql, p)
        cur.execute(sql2, p2 or [])
    return cur


def query(conn, sql: str, params: Dict[str, Any] | None = None):
    cur = execute(conn, sql, params)
    return cur.fetchall()


def normalize_error(exc: Exception) -> DBError:
    # sqlite3.IntegrityError cobre UNIQUE, FK etc.
    if isinstance(exc, sqlite3.IntegrityError):
        msg = str(exc).lower()
        if "unique" in msg:
            return DuplicateKeyError(str(exc))
        if "foreign key" in msg:
            return ForeignKeyError(str(exc))
    return DBError(str(exc))


==================================================
FILE: .\backend\db\__init__.py
==================================================
from backend.core.config import settings

_BACKEND = settings.DB_BACKEND
_DSN = settings.DB_DSN

if _BACKEND == "sqlite":
    from . import sqlite_adapter as _adapter
else:
    from . import postgres_adapter as _adapter

connect = _adapter.connect
execute = _adapter.execute
executemany = _adapter.executemany
query = _adapter.query
normalize_error = _adapter.normalize_error


def backend_name() -> str:
    return _BACKEND


def dsn() -> str | None:
    return _DSN


==================================================
FILE: .\backend\notifications\email_service.py
==================================================
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from backend.core.config import settings


def send_email(to_email: str, subject: str, html_content: str):

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subject
    msg["From"] = settings.EMAIL_FROM
    msg["To"] = to_email

    part = MIMEText(html_content, "html")
    msg.attach(part)

    with smtplib.SMTP(settings.SMTP_HOST, settings.SMTP_PORT) as server:
        server.starttls()
        server.login(settings.SMTP_USER, settings.SMTP_PASSWORD)
        server.send_message(msg)
        server.quit()


==================================================
FILE: .\backend\notifications\templates.py
==================================================
def reset_password_template(reset_link: str) -> str:
    return f"""
    <html>
        <body style="font-family: Arial, sans-serif; background-color: #f4f6f8; padding: 20px;">
            <div style="max-width: 600px; margin: auto; background: white; padding: 30px; border-radius: 8px;">
                <h2 style="color: #1f2937;">Redefini√ß√£o de Senha</h2>
                <p>Voc√™ solicitou a redefini√ß√£o de sua senha.</p>
                <p>Clique no bot√£o abaixo:</p>

                <a href="{reset_link}"
                   style="display: inline-block; padding: 12px 20px; background-color: #2563eb; color: white; text-decoration: none; border-radius: 6px;">
                   Redefinir Senha
                </a>

                <p style="margin-top: 20px; font-size: 12px; color: #6b7280;">
                    Este link expira em 30 minutos.
                </p>
            </div>
        </body>
    </html>
    """


==================================================
FILE: .\backend\users\admin.py
==================================================
from fastapi import APIRouter, Depends, HTTPException

from backend.audit.service import registrar_evento
from backend.auth.dependencies import get_current_user, get_current_user_allow_password_change
from backend.auth.permissions import require_role
from backend.auth.service import login_user
from backend.db import connect, execute, query
from backend.users.password_reset_service import limpar_tokens_reset_expirados_ou_usados
from backend.users.schemas import ChangePasswordIn
from backend.users.service import alterar_senha, resetar_senha_admin

router = APIRouter(prefix="/admin", tags=["Admin"])


@router.get("/users")
def listar_usuarios(user=Depends(get_current_user)):
    require_role("admin")(user)
    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT id, username, role, created_at
              FROM users
             ORDER BY username
            """,
            {},
        )
        return [dict(row) for row in rows]
    finally:
        conn.close()


@router.get("/users/{username}/check")
def check_user(username: str, user=Depends(get_current_user)):
    return {
        "username": user.username,
        "role": user.role,
        "must_change_password": bool(user.must_change_password),
        "password_expiring_soon": bool(user.password_expiring_soon),
        "password_days_remaining": int(user.password_days_remaining),
    }


@router.post("/users/{username}/reset-password")
def reset_password(username: str, user=Depends(get_current_user)):
    require_role("admin")(user)
    nova_senha = resetar_senha_admin(username, user)

    return {
        "username": username,
        "temporary_password": nova_senha,
        "warning": "Copie a senha agora. Ela n√£o ser√° exibida novamente.",
    }


@router.post("/password-reset/cleanup")
def cleanup_password_reset_tokens(user=Depends(get_current_user)):
    require_role("admin")(user)
    deleted = limpar_tokens_reset_expirados_ou_usados()
    return {
        "deleted_tokens": deleted,
        "message": "Tokens expirados/usados removidos com sucesso",
    }


@router.post("/change-password")
def change_password(
    payload: ChangePasswordIn, user=Depends(get_current_user_allow_password_change)
):
    try:
        alterar_senha(
            username=user.username,
            senha_atual=payload.old_password,
            nova_senha=payload.new_password,
        )

        # # üîê cria nova sess√£o (zera contexto antigo)
        # access_token, refresh_token = login_user(
        #     user.username,
        #     user.role,
        # )

        registrar_evento(
            username=user.username,
            role=user.role,
            action="CHANGE_PASSWORD",
            resource="users",
            resource_id=None,
            payload_before=None,
            payload_after=None,
            endpoint="/change-password",
            method="POST",
        )

        return {"message": "Senha alterada com sucesso"}
        # return {
        #     "access_token": access_token,
        #     "refresh_token": refresh_token,
        #     "user": {
        #         "username": user.username,
        #         "role": user.role,
        #     },
        # }

    except HTTPException as exc:
        # ‚ö†Ô∏è Erros de neg√≥cio esperados (senha inv√°lida, pol√≠tica, etc)
        raise exc
    except Exception:
        # üî• Erros inesperados
        raise HTTPException(
            status_code=500,
            detail="Erro interno ao alterar senha",
        )


@router.put("/users/{username}/email")
def update_user_email(
    username: str,
    payload: dict,
    admin=Depends(get_current_user),
):
    require_role("admin")(admin)

    new_email = payload.get("email")
    if not new_email:
        raise HTTPException(status_code=400, detail="Email obrigat√≥rio")

    conn = connect()
    try:
        # valida se j√° existe
        existing_user = query(
            conn,
            """
            SELECT 1
              FROM users
             WHERE username != :username
               AND email = :email
            """,
            {"username": username, "email": new_email},
        )
        if existing_user:
            raise HTTPException(status_code=400, detail="EMAIL_ALREADY_IN_USE")

        execute(
            conn,
            """
            UPDATE users
               SET email = :email
             WHERE username = :username
            """,
            {"username": username, "email": new_email},
        )

        conn.commit()

        return {"message": "Email atualizado com sucesso"}
    except Exception as exc:
        conn.rollback()
        raise exc
    finally:
        conn.close()


==================================================
FILE: .\backend\users\bootstrap.py
==================================================
from datetime import datetime, timezone

from backend.auth.passwords import hash_password
from backend.db import connect, execute

USERS = [
    ("admin", "admin", "admin", "email01@test.com"),
    ("editor", "editor", "editor", "email02@test.com"),
    ("leitor", "leitor", "leitor", "email03@test.com"),
]


def create_inicial_users():
    conn = connect()
    try:
        for username, password, role, email in USERS:
            execute(
                conn,
                """
                INSERT OR IGNORE INTO users
                    (username, password_hash, role, email, created_at)
                VALUES
                    (:username, :password_hash, :role, :email, :created_at)
                """,
                {
                    "username": username,
                    "password_hash": hash_password(password),
                    "role": role,
                    "email": email,
                    "created_at": datetime.now(timezone.utc).isoformat(),
                },
            )
            conn.commit()
    finally:
        conn.close()


if __name__ == "__main__":
    create_inicial_users()
    print("Usu√°rios iniciais criados com sucesso.")


==================================================
FILE: .\backend\users\models.py
==================================================
from pydantic import BaseModel


class ForgotPasswordIn(BaseModel):
    username: str


class ResetPasswordIn(BaseModel):
    token: str
    new_password: str


==================================================
FILE: .\backend\users\password_reset_service.py
==================================================
import hashlib
import hmac
import secrets
from datetime import datetime, timedelta, timezone

from fastapi import HTTPException

from backend.auth.service import revoke_all_sessions
from backend.core.config import settings
from backend.db import connect, execute, query


def gerar_token_reset_senha(*, username: str, validade_minutos: int = 30) -> str:
    """
    Gera token tempor√°rio de reset de senha.
    Retorna o token PURO (para envio por e-mail).
    """

    # token imprev√≠sivel (URL-safe)
    token = secrets.token_urlsafe(32)

    token_hash = hashlib.sha256(token.encode()).hexdigest()

    now = datetime.now(timezone.utc)
    expires_at = now + timedelta(minutes=validade_minutos)

    conn = connect()
    try:
        execute(
            conn,
            """
            INSERT INTO password_reset_tokens (
                username,
                token_hash,
                created_at,
                expires_at
            )
            VALUES (
                :username,
                :token_hash,
                :created_at,
                :expires_at
            )
            """,
            {
                "username": username,
                "token_hash": token_hash,
                "created_at": now.isoformat(),
                "expires_at": expires_at.isoformat(),
            },
        )

        revoke_all_sessions(username, conn=conn)

        conn.commit()
    finally:
        conn.close()

    # ‚ö†Ô∏è SOMENTE o token puro sai daqui
    return token


def validar_token_reset_senha(*, token: str) -> str:
    """
    Valida token de reset.
    Retorna username se v√°lido.
    """

    token_hash = hashlib.sha256(token.encode()).hexdigest()

    now = datetime.now(timezone.utc)

    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT
              id, username, expires_at, used_at
            FROM password_reset_tokens
            WHERE token_hash = :token_hash
            """,
            {"token_hash": token_hash},
        )

        if not rows:
            raise HTTPException(status_code=400, detail="Token inv√°lido")

        row = rows[0]

        if row["used_at"] is not None:
            raise HTTPException(status_code=400, detail="Token j√° utilizado")

        if now > datetime.fromisoformat(row["expires_at"]):
            raise HTTPException(status_code=400, detail="Token expirado")

        return row["username"]
    finally:
        conn.close()


def assinar_token_reset(token: str) -> str:
    """
    Assina o token com HMAC usando JWT_SECRET.
    Retorna token + assinatura concatenados.
    """
    signature = hmac.new(
        settings.JWT_SECRET.encode(),
        token.encode(),
        hashlib.sha256,
    ).hexdigest()

    return f"{token}.{signature}"


def validar_assinatura_token(token_assinado: str) -> str:
    """
    Separa token e assinatura.
    Valida integridade.
    Retorna token puro se v√°lido.
    """
    try:
        token, signature = token_assinado.split(".")
    except ValueError:
        raise HTTPException(status_code=400, detail="Token inv√°lido")

    expected_signature = hmac.new(
        settings.JWT_SECRET.encode(),
        token.encode(),
        hashlib.sha256,
    ).hexdigest()

    if not hmac.compare_digest(signature, expected_signature):
        raise HTTPException(status_code=400, detail="Token inv√°lido")

    return token


def marcar_token_como_usado(*, token: str):
    token_hash = hashlib.sha256(token.encode()).hexdigest()
    now = datetime.now(timezone.utc)

    conn = connect()
    try:
        execute(
            conn,
            """
            UPDATE password_reset_tokens
               SET used_at = :used_at
             WHERE token_hash = :token_hash
            """,
            {
                "used_at": now.isoformat(),
                "token_hash": token_hash,
            },
        )
        conn.commit()
    finally:
        conn.close()


def limpar_tokens_reset_expirados_ou_usados() -> int:
    """
    Remove tokens expirados ou j√° utilizados.
    Retorna a quantidade removida.
    """
    conn = connect()
    try:
        cur = execute(
            conn,
            """
            DELETE FROM password_reset_tokens
             WHERE used_at IS NOT NULL
                OR expires_at <= CURRENT_TIMESTAMP
            """,
            {},
        )
        conn.commit()
        return cur.rowcount
    finally:
        conn.close()


==================================================
FILE: .\backend\users\schemas.py
==================================================
from pydantic import BaseModel


class ChangePasswordIn(BaseModel):
    old_password: str
    new_password: str


class UserProfileUpdate(BaseModel):
    email: str
    name: str
    fullname: str


==================================================
FILE: .\backend\users\service.py
==================================================
import re
import secrets
import string
from datetime import datetime, timedelta, timezone

from fastapi import HTTPException

from backend.audit.service import registrar_evento
from backend.auth.passwords import hash_password, verify_password
from backend.auth.service import revoke_all_sessions
from backend.core.config import settings
from backend.db import connect, execute, query
from backend.models import UserContext


def authenticate_user(username: str, password: str):
    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT username, password_hash, role, is_active, must_change_password, password_expires_at,
                   email, name, fullname, avatar_path
              FROM users
             WHERE username = :username
            """,
            {"username": username},
        )
    finally:
        conn.close()

    if not rows:
        return None

    user = rows[0]

    if not user["is_active"]:
        return None

    if not verify_password(password, user["password_hash"]):
        return None

    expiring_soon = False
    days_remaining = None

    password_expires_at = user["password_expires_at"]
    if password_expires_at:
        password_expires_datetime = datetime.fromisoformat(password_expires_at)
        time_until_expiration = password_expires_datetime - datetime.now(timezone.utc)

        days_remaining = time_until_expiration.days

        if days_remaining <= settings.PASSWORD_EXPIRATION_WARNING_DAYS:
            expiring_soon = True

    return {
        "username": user["username"],
        "role": user["role"],
        "email": user["email"],
        "name": user["name"],
        "fullname": user["fullname"],
        "avatar_path": user["avatar_path"],
        "must_change_password": bool(user["must_change_password"]),
        "password_expiring_soon": expiring_soon,
        "password_days_remaining": days_remaining,
    }


def validar_senha(password: str):
    if len(password) < 6:
        raise ValueError("Senha deve ter no m√≠nimo 6 caracteres")

    if not re.search(r"[A-Z]", password):
        raise ValueError("Senha deve conter letra mai√∫scula")

    if not re.search(r"[a-z]", password):
        raise ValueError("Senha deve conter letra min√∫scula")

    if not re.search(r"\d", password):
        raise ValueError("Senha deve conter n√∫mero")

    if not re.search(r"[^\w\s]", password):
        raise ValueError("Senha deve conter caractere especial")


def gerar_senha_temporaria(tamanho: int = 6) -> str:
    minusculas = string.ascii_lowercase
    maiusculas = string.ascii_uppercase
    numeros = string.digits
    caracteres_especiais = string.punctuation

    # 1Ô∏è‚É£ garante 1 de cada
    senha = [
        secrets.choice(minusculas),
        secrets.choice(maiusculas),
        secrets.choice(numeros),
        secrets.choice(caracteres_especiais),
    ]

    # 2Ô∏è‚É£ completa o resto
    todos = minusculas + maiusculas + numeros + caracteres_especiais
    senha += [secrets.choice(todos) for _ in range(2)]

    # 3Ô∏è‚É£ embaralha
    secrets.SystemRandom().shuffle(senha)
    return "".join(senha)


def resetar_senha_admin(username: str, admin_user: UserContext):
    # gera senha tempor√°ria
    nova_senha = gerar_senha_temporaria()

    # valida senha tempor√°ria
    validar_senha(nova_senha)

    conn = connect()
    try:
        # üîê Atualiza senha
        execute(
            conn,
            """
            UPDATE users
               SET password_hash = :hash,
                   must_change_password = 1
             WHERE username = :username
            """,
            {
                "hash": hash_password(nova_senha),
                "username": username,
            },
        )

        revoke_all_sessions(username, conn=conn)

        # üßæ Auditoria (MESMA conex√£o)
        registrar_evento(
            conn=conn,
            username=admin_user.username,
            role=admin_user.role,
            action="RESET_PASSWORD_ADMIN",
            resource="users/admin",
            resource_id=None,
            payload_before={"username": username},
            payload_after=None,
            endpoint="/admin/users/reset-password",
            method="POST",
        )

        conn.commit()
        return nova_senha
    except Exception as exc:
        conn.rollback()
        raise exc
    finally:
        conn.close()


def alterar_senha(*, username: str, senha_atual: str, nova_senha: str):
    try:
        validar_senha(nova_senha)
    except ValueError as exc:
        # ‚ùå Pol√≠tica de senha
        raise HTTPException(status_code=400, detail=str(exc))

    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT password_hash
              FROM users
             WHERE username = :username
            """,
            {"username": username},
        )

        if not rows:
            raise HTTPException(status_code=404, detail="Usu√°rio n√£o encontrado")

        password_hash = rows[0]["password_hash"]

        if not verify_password(senha_atual, password_hash):
            raise HTTPException(status_code=400, detail="Senha atual inv√°lida")

        execute(
            conn,
            """
            UPDATE users
               SET password_hash = :password_hash,
                   must_change_password = 0,
                   password_changed_at = :changed_at,
                   password_expires_at = :expires_at
             WHERE username = :username
            """,
            {
                "password_hash": hash_password(nova_senha),
                "username": username,
                "changed_at": datetime.now(timezone.utc).isoformat(),
                "expires_at": (
                    datetime.now(timezone.utc) + timedelta(days=settings.PASSWORD_VALIDITY_DAYS)
                ).isoformat(),
            },
        )

        revoke_all_sessions(username, conn=conn)

        conn.commit()
    finally:
        conn.close()


def resetar_senha_por_token(*, username: str, nova_senha: str):
    """
    Reseta a senha sem exigir a senha atual (uso com token v√°lido).
    """
    try:
        validar_senha(nova_senha)
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc))

    conn = connect()
    try:
        rows = query(
            conn,
            """
            SELECT password_hash
              FROM users
             WHERE username = :username
               AND is_active = 1
            """,
            {"username": username},
        )

        if not rows:
            raise HTTPException(status_code=404, detail="Usu√°rio n√£o encontrado")

        execute(
            conn,
            """
            UPDATE users
               SET password_hash = :password_hash,
                   must_change_password = 0,
                   password_changed_at = :changed_at,
                   password_expires_at = :expires_at
             WHERE username = :username
            """,
            {
                "password_hash": hash_password(nova_senha),
                "username": username,
                "changed_at": datetime.now(timezone.utc).isoformat(),
                "expires_at": (
                    datetime.now(timezone.utc) + timedelta(days=settings.PASSWORD_VALIDITY_DAYS)
                ).isoformat(),
            },
        )

        conn.commit()
    finally:
        conn.close()


==================================================
FILE: .\backend\users\users.py
==================================================
import shutil
from pathlib import Path

from fastapi import APIRouter, BackgroundTasks, Depends, File, HTTPException, UploadFile

from backend.audit.service import registrar_evento
from backend.auth.dependencies import get_current_user, get_current_user_profile
from backend.auth.service import revoke_all_sessions
from backend.core.config import settings
from backend.core.logger import logger
from backend.db import connect, execute, query
from backend.models import User, UserContext
from backend.notifications.email_service import send_email
from backend.notifications.templates import reset_password_template
from backend.users.models import ForgotPasswordIn, ResetPasswordIn
from backend.users.password_reset_service import (
    assinar_token_reset,
    gerar_token_reset_senha,
    marcar_token_como_usado,
    validar_assinatura_token,
    validar_token_reset_senha,
)
from backend.users.schemas import UserProfileUpdate
from backend.users.service import resetar_senha_por_token

router = APIRouter(tags=["Users"])


def _send_email_safe(to: str, subject: str, html: str):
    try:
        send_email(to, subject, html)
    except Exception as exc:
        # Em dev, √© comum o email falhar se for fake. Apenas logamos o aviso.
        logger.warning(f"Falha ao enviar e-mail para {to}: {exc}")


@router.post("/forgot-password")
def forgot_password(payload: ForgotPasswordIn, background_tasks: BackgroundTasks):
    """
    Gera token de reset de senha.
    Em produ√ß√£o, o token deve ser enviado por e-mail.
    """
    username = payload.username.strip()
    if not username:
        raise HTTPException(status_code=400, detail="Username obrigat√≥rio")

    try:
        logger.info("Forgot-password solicitado")
        conn = connect()
        try:
            rows = query(
                conn,
                """
                SELECT email
                  FROM users
                 WHERE username = :username
                   AND is_active = 1
                """,
                {"username": username},
            )
        finally:
            conn.close()

        token = None
        signed_token = None

        if rows:
            logger.info("Usu√°rio ativo encontrado para reset de senha")

            email = rows[0]["email"]

            # 1Ô∏è‚É£ Gerar token puro
            token = gerar_token_reset_senha(username=username)

            # 2Ô∏è‚É£ Assinar token
            signed_token = assinar_token_reset(token)

            # 3Ô∏è‚É£ Criar link
            reset_link = f"{settings.FRONTEND_URL}?token={signed_token}"

            # 4Ô∏è‚É£ Criar HTML
            html_content = reset_password_template(reset_link)

            # 5Ô∏è‚É£ Enviar e-mail em background
            if email:
                background_tasks.add_task(
                    _send_email_safe,
                    email,
                    "Redefini√ß√£o de senha",
                    html_content,
                )
            else:
                logger.warning(
                    f"Usu√°rio {username} solicitou reset mas n√£o possui e-mail cadastrado."
                )
        else:
            logger.info("Usu√°rio n√£o encontrado ou inativo para reset de senha")

        registrar_evento(
            username=username,
            role="system",
            action="FORGOT_PASSWORD",
            resource="users",
            resource_id=None,
            payload_before=None,
            payload_after=None,
            endpoint="/forgot-password",
            method="POST",
        )

        # 200 gen√©rico para n√£o revelar se o usu√°rio existe
        response = {
            "message": "Se o usu√°rio existir, voc√™ receber√° instru√ß√µes para redefinir a senha."
        }

        # ‚ö†Ô∏è Apenas em desenvolvimento, retorna o token no response
        if settings.ENV == "dev" and signed_token:
            response["reset_token"] = signed_token
            logger.warning(f"Token de reset: {signed_token}")

        return response

    except HTTPException:
        logger.warning("Erro de valida√ß√£o ao solicitar reset de senha", exc_info=True)
        raise
    except Exception:
        logger.exception("Erro inesperado no fluxo de forgot-password")
        raise HTTPException(
            status_code=500,
            detail="Erro interno ao solicitar redefini√ß√£o de senha",
        )


@router.post("/reset-password")
def reset_password(payload: ResetPasswordIn):
    """
    Reseta senha usando token.
    """
    try:
        logger.info("Reset-password solicitado")

        # 1Ô∏è‚É£ Validar assinatura primeiro
        token_puro = validar_assinatura_token(payload.token)

        # 2Ô∏è‚É£ Validar token no banco
        username = validar_token_reset_senha(token=token_puro)

        # 3Ô∏è‚É£ Alterar senha (aplica pol√≠tica)
        resetar_senha_por_token(username=username, nova_senha=payload.new_password)

        # 4Ô∏è‚É£ Marcar token como usado
        marcar_token_como_usado(token=token_puro)

        # 5Ô∏è‚É£ Revoga sess√µes do usu√°rio
        revoke_all_sessions(username)

        # 6Ô∏è‚É£ Auditoria
        registrar_evento(
            username=username,
            role="system",
            action="RESET_PASSWORD_TOKEN",
            resource="users",
            resource_id=None,
            payload_before=None,
            payload_after=None,
            endpoint="/reset-password",
            method="POST",
        )

        return {"message": "Senha redefinida com sucesso"}

    except HTTPException:
        # Resposta gen√©rica para evitar enumera√ß√£o de tokens inv√°lidos/usados/expirados
        logger.warning("Reset-password com falha de valida√ß√£o", exc_info=True)
        return {"message": "Se o token for v√°lido, a senha ser√° redefinida."}
    except Exception:
        logger.exception("Erro inesperado no fluxo de reset-password")
        raise HTTPException(
            status_code=500,
            detail="Erro interno ao redefinir a senha",
        )


@router.get("/me", response_model=User)
def get_me(user: User = Depends(get_current_user_profile)):
    return user


@router.put("/me/profile")
def update_profile(
    payload: UserProfileUpdate,
    user: UserContext = Depends(get_current_user),
):
    conn = connect()
    try:
        # valida email √∫nico
        exists = query(
            conn,
            "SELECT 1 FROM users WHERE email = :email AND username != :username",
            {"email": payload.email, "username": user.username},
        )
        if exists:
            raise HTTPException(status_code=400, detail="EMAIL_ALREADY_EXISTS")

        execute(
            conn,
            """
            UPDATE users
            SET email = :email,
                name = :name,
                fullname = :fullname
            WHERE username = :username
            """,
            {
                "email": payload.email,
                "name": payload.name,
                "fullname": payload.fullname,
                "username": user.username,
            },
        )

        registrar_evento(
            conn=conn,
            username=user.username,
            role=user.role,
            action="UPDATE_PROFILE",
            resource="users",
            resource_id=None,
            payload_before=None,
            payload_after=payload.model_dump(),
            endpoint="/me/profile",
            method="PUT",
        )
        conn.commit()

        return {"message": "Perfil atualizado"}
    finally:
        conn.close()


@router.post("/me/avatar")
def upload_avatar(
    file: UploadFile = File(...),
    user: UserContext = Depends(get_current_user),
):
    # 1. Valida√ß√£o de Tipo (MIME)
    if file.content_type not in ["image/jpeg", "image/png"]:
        raise HTTPException(status_code=400, detail="INVALID_FILE_TYPE")

    # 2. Valida√ß√£o de Tamanho (2MB)
    # Move o cursor para o final para ler o tamanho
    file.file.seek(0, 2)
    size = file.file.tell()
    # Retorna o cursor para o in√≠cio para poder salvar depois
    file.file.seek(0)

    if size > 2 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="FILE_TOO_LARGE")

    # 3. Preparar diret√≥rio e caminho
    upload_dir = Path("backend/static/avatars")
    upload_dir.mkdir(parents=True, exist_ok=True)

    extension = ".png" if "png" in file.content_type else ".jpg"
    filename = f"{user.username}{extension}"
    file_path = upload_dir / filename

    # 4. Salvar arquivo
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)

    # Caminho relativo para salvar no banco (para o frontend acessar via StaticFiles)
    db_path = f"/static/avatars/{filename}"

    conn = connect()
    try:
        execute(
            conn,
            "UPDATE users SET avatar_path = :path WHERE username = :username",
            {"path": db_path, "username": user.username},
        )

        registrar_evento(
            conn=conn,
            username=user.username,
            role=user.role,
            action="UPLOAD_AVATAR",
            resource="users",
            resource_id=None,
            payload_before=None,
            payload_after={"avatar_path": db_path},
            endpoint="/me/avatar",
            method="POST",
        )
        conn.commit()
    finally:
        conn.close()

    return {"message": "Avatar atualizado", "path": db_path}


==================================================
FILE: .\frontend\app_config.py
==================================================
# frontend/app_config.py
import streamlit as st


def init_page(
    page_title: str = "Painel de Dados",
    page_icon: str = ":bar_chart:",
    wide: bool = True,
    sidebar_state: str = "auto",
    menu_items: dict | None = None,
) -> None:
    """
    Inicializa a p√°gina Streamlit com configura√ß√µes padr√£o da UI.
    - Chame no topo de CADA p√°gina (incluindo a p√°gina inicial).
    - Em Streamlit recentes, chamadas repetidas sobrescrevem apenas o que voc√™ passar.
    """
    layout = "wide" if wide else "centered"
    st.set_page_config(
        page_title=page_title,
        page_icon=page_icon,
        layout=layout,
        initial_sidebar_state=sidebar_state,
        menu_items=menu_items,
    )


==================================================
FILE: .\frontend\Home.py
==================================================
import streamlit as st
from charts.charts import grafico_evolucao

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.loaders.registros import carregar_registros
from frontend.services.navigation import set_current_page

# üîê Interceptar reset token antes de exigir autentica√ß√£o
token = st.query_params.get("token", None)

if token:
    st.session_state.reset_token_from_link = token
    st.switch_page(Page.RESET_PASSWORD.path)
    st.stop()


set_current_page(Page.HOME)

api, user = base_layout("Home ‚Ä¢ Painel", ":house:", wide=True)

# st.code(user)

if user and user.get("password_expiring_soon"):
    dias = user.get("password_days_remaining")
    if dias > 0:
        st.warning(
            f"""Sua senha expira em {dias} dias.
                Recomendamos alterar antecipadamente.
            """,
            icon="‚ö†Ô∏è",
        )


st.title("üìä Painel Evolutivo de Dados")

df = carregar_registros()

# --- ler query params ---
query_params = st.query_params
categoria_qp = query_params.get("categoria", [None])[0]

# --- inicializar estado ---
if "categoria" not in st.session_state:
    st.session_state.categoria = categoria_qp or df["categoria"].iloc[0]

categorias = df["categoria"].unique()

# --- sidebar ---
with st.sidebar:
    try:
        cat_idx = categorias.tolist().index(st.session_state.categoria)
    except ValueError:
        cat_idx = 0

    categoria = st.selectbox(
        "Categoria",
        options=df["categoria"].unique(),
        index=cat_idx,
    )

    st.divider()

    st.write("Access token")
    st.code(st.session_state.get("access_token"))

    st.write("Refresh token")
    st.code(st.session_state.get("refresh_token"))

    if st.button("Recarregar dados"):
        st.cache_data.clear()
        st.success("Dados recarregados")
        st.rerun()

    if st.button("Listar registros teste"):
        resp = api.listar_registros()
        st.success("Registros listados")
        st.write(resp.json())


# --- salvar no estado e na URL ---
st.session_state.categoria = categoria
st.query_params.categoria = categoria


df_filtrado = df[df["categoria"] == categoria]

st.markdown(
    """
    <style>
    div[data-testid="stHorizontalBlock"] > div:nth-child(2) {
        padding-left: 50px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)

# --- layout ---
col1, col2 = st.columns([2, 1])

with col1:
    fig = grafico_evolucao(df_filtrado, categoria)
    st.plotly_chart(fig, width="stretch")

with col2:
    st.metric(label="Total de registros", value=len(df_filtrado))
    st.metric(label="Soma do valor", value=df_filtrado["valor"].sum())


==================================================
FILE: .\frontend\__init__.py
==================================================


==================================================
FILE: .\frontend\charts\charts.py
==================================================
import plotly.express as px


def grafico_evolucao(df, categoria):
    fig = px.line(df, x="data", y="valor", title=f"Evolu√ß√£o da categoria {categoria}")
    return fig


==================================================
FILE: .\frontend\components\user_menu.py
==================================================
import time

import streamlit as st

from backend.core.config import settings
from frontend.core.pages import Page
from frontend.util.greeting import saudacao_usuario


def render_user_menu(api, user):
    if not user:
        return

    nome = user.get("name") or user.get("username")
    saudacao = saudacao_usuario(nome)

    # L√≥gica para montar a URL completa da imagem
    avatar_path = user.get("avatar_path")
    if avatar_path:
        # Se for caminho relativo (/static...), concatena com a URL da API
        if avatar_path.startswith("/"):
            avatar_url = f"{settings.API_BASE_URL}{avatar_path}?v={int(time.time())}"
        else:
            avatar_url = avatar_path
    else:
        # Avatar padr√£o (placeholder)
        avatar_url = f"https://ui-avatars.com/api/?name={nome}&background=random"

    with st.sidebar:
        st.markdown(
            f"""
        <div style="display:flex;align-items:center;gap:10px;padding: 10px 0;">
            <img src="{avatar_url}" style="width:40px;height:40px;border-radius:50%;object-fit:cover;border: 2px solid #e0e0e0;">
            <div style="line-height: 1.1;">
                <div style="font-size: 11px; color: gray;">{saudacao}</div>
                <div style="font-weight:600; font-size: 13px;">{user.get("role", "").upper()}</div>
            </div>
        </div>
        <hr style="margin: 5px 0 10px 0;">
        """,
            unsafe_allow_html=True,
        )

        # Menu de navega√ß√£o r√°pida
        st.markdown(
            '<div style="font-size: 12px; font-weight: 600; color: #666; margin-bottom: 5px;">‚öôÔ∏è CONTA</div>',
            unsafe_allow_html=True,
        )

        if st.button("üë§ Meu Perfil", use_container_width=True):
            st.switch_page(Page.PROFILE.path)

        if st.button("üîê Trocar Senha", use_container_width=True):
            st.switch_page(Page.CHANGE_PASSWORD.path)

        if st.button("üö™ Sair", type="primary", use_container_width=True):
            api.logout()
            st.session_state.clear()
            st.switch_page(Page.LOGIN.path)


==================================================
FILE: .\frontend\core\pages.py
==================================================
from enum import Enum


class Page(Enum):
    LOGIN = ("login", "pages/0_üîê_Login.py")
    HOME = ("home", "Home.py")
    DATA = ("data", "pages/1_üìÑ_Dados.py")
    GERENCIAR = ("gerenciar", "pages/2_‚úèÔ∏è_Gerenciar.py")
    AUDITORIA = ("auditoria", "pages/3_üìú_Auditoria.py")
    ADMIN = ("admin", "pages/4_üõ†Ô∏è_Administra√ß√£o.py")
    INTEGRIDADE = ("integridade", "pages/5_üîê_Integridade_Auditoria.py")
    USERS = ("users", "pages/6_üßë‚Äçüíº_Usu√°rios.py")
    CHANGE_PASSWORD = ("change_password", "pages/7_üîë_Troca_de_Senha.py")
    RESET_PASSWORD = ("reset_password", "pages/8_üîë_Redefinir_Senha.py")
    PROFILE = ("profile", "pages/9_üë§_Perfil.py")

    def __init__(self, key, path):
        self.key = key
        self.path = path


==================================================
FILE: .\frontend\layouts\base_layout.py
==================================================
import streamlit as st

from frontend.components.user_menu import render_user_menu
from frontend.services.session import require_auth

# ‚öôÔ∏è Settings de Estilo da Sidebar
SIDEBAR_FONT_SIZE = "14px"
SIDEBAR_BUTTON_SIZE = "13px"


def base_layout(page_title: str, page_icon: str, wide: bool = False):
    # 1. Configura√ß√£o da p√°gina deve ser SEMPRE a primeira instru√ß√£o Streamlit
    layout_mode = "wide" if wide else "centered"

    try:
        st.set_page_config(page_title=page_title, page_icon=page_icon, layout=layout_mode)
    except Exception:
        # Evita erro se set_page_config for chamado duas vezes (bug comum no Streamlit)
        pass

    # üé® Inje√ß√£o de CSS para ajuste fino da Sidebar
    st.markdown(
        f"""
        <style>
        /* Ajuste global de fontes na sidebar (afeta textos soltos) */
        section[data-testid="stSidebar"] * {{
            font-size: {SIDEBAR_FONT_SIZE} !important;
        }}

        /* Bot√µes mais compactos e com fonte menor */
        section[data-testid="stSidebar"] .stButton button {{
            font-size: {SIDEBAR_BUTTON_SIZE} !important;
            padding-top: 4px !important;
            padding-bottom: 4px !important;
            padding-left: 10px !important;
            padding-right: 10px !important;
            min-height: 0px !important;
            height: auto !important;
            line-height: 1.2 !important;
            margin-top: 2px !important;
            margin-bottom: 2px !important;
        }}
        </style>
        """,
        unsafe_allow_html=True,
    )

    # 2. Verifica autentica√ß√£o
    api, user = require_auth()

    # üîÑ Recupera√ß√£o de dados completos (Avatar/Email)
    # Se o objeto user vier apenas do token (sem avatar_path), buscamos o perfil completo
    if user and "avatar_path" not in user:
        try:
            resp = api._request("GET", "/me")
            if resp.status_code == 200:
                full_data = resp.json()
                user.update(full_data)
                st.session_state.user = user
        except Exception:
            pass

    # 3. Renderiza menu lateral
    render_user_menu(api, user)

    return api, user


==================================================
FILE: .\frontend\loaders\registros.py
==================================================
import pandas as pd
import streamlit as st
from fastapi import Response

from backend.core.config import settings
from frontend.services.api import APIClient


@st.cache_data
def carregar_registros():
    """
    _api come√ßa com underscore:
    - N√ÉO entra no hash do cache
    - mas continua sendo usado
    """
    resp: Response = APIClient.listar_registros_publico(settings.API_BASE_URL)

    if resp.status_code != 200:
        raise RuntimeError(f"Erro ao carregar registros: {resp.status_code} - {resp.text}")

    dados = resp.json()
    df = pd.DataFrame(dados)

    if "data" in df.columns:
        df["data"] = pd.to_datetime(df["data"], errors="coerce")
        df["data"] = df["data"].dt.normalize()
    return df


==================================================
FILE: .\frontend\pages\0_üîê_Login.py
==================================================
import time

import requests
import streamlit as st

from backend.core.config import settings
from frontend.app_config import init_page
from frontend.core.pages import Page
from frontend.services.api import APIClient

user = st.session_state.get("user")

login_error_message = st.session_state.get("login_error_message")

if login_error_message:
    st.toast(st.session_state.get("login_error_message"))

if user:
    st.info(
        f"Voc√™ *j√° est√° logado* como :orange[-> **{user['username']}**] e com o n√≠vel de permiss√£o :orange[-> **{user['role']}**]",
        icon=":material/info:",
    )
    time.sleep(3)
    st.switch_page("Home.py")
    st.stop()


api = APIClient(
    base_url=settings.API_BASE_URL,
    access_token=st.session_state.get("access_token"),
    refresh_token=st.session_state.get("refresh_token"),
)

st.session_state.api = api

init_page(page_title="Login", page_icon="üîê")
st.title("üîê Login")

st.session_state.setdefault("login_in_progress", False)

st.markdown(
    """
    <style>
    /* Caixa de login baseada no bloco que cont√©m o marcador */
    div[data-testid="stVerticalBlock"]:has(> div[data-testid="stMarkdown"] [data-login-box-marker]) {
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(255, 255, 255, 0.02);
        padding: 20px 22px;
        border-radius: 12px;
        margin-top: 8px;
    }
    /* Espa√ßamento interno entre widgets */
    div[data-testid="stVerticalBlock"]:has(> div[data-testid="stMarkdown"] [data-login-box-marker]) > div {
        gap: 0.5rem;
    }
    /* Esconde o marcador visual */
    [data-login-box-marker] { display: none; }
    div[data-testid="stForm"] {
        border: none;
        padding: 0;
        margin: 0;
    }
    </style>
    """,
    unsafe_allow_html=True,
)


@st.dialog("üîÅ Recuperar senha")
def forgot_password_dialog(prefill_username: str | None = None):
    st.caption("Informe seu usu√°rio para receber instru√ß√µes de redefini√ß√£o.")
    with st.form("forgot_password_form", enter_to_submit=True):
        username = st.text_input(
            "Usu√°rio",
            value=prefill_username or "",
            placeholder="Digite seu usu√°rio",
        )
        submitted = st.form_submit_button("Enviar", type="primary")

    if submitted:
        if not username.strip():
            st.toast("Informe o usu√°rio.")
            return

        with st.spinner("Enviando solicita√ß√£o..."):
            try:
                requests.post(
                    f"{settings.API_BASE_URL}/forgot-password",
                    json={"username": username.strip()},
                    timeout=10,
                )
                # üîí Sempre resposta gen√©rica
                st.success("Se o usu√°rio existir, voc√™ receber√° instru√ß√µes para redefinir a senha.")
            except requests.exceptions.ConnectionError:
                st.error("N√£o foi poss√≠vel conectar √† API.")
            except Exception as e:
                st.error(f"Erro inesperado: {e}")

    st.divider()
    if st.button("J√° tenho um token"):
        st.switch_page(Page.RESET_PASSWORD.path)


with st.container(
    border=True,
):
    st.markdown('<span data-login-box-marker="true"></span>', unsafe_allow_html=True)
    username = st.text_input("Usu√°rio", key="login_username")
    with st.form("login", enter_to_submit=True):
        password = st.text_input("Senha", type="password", key="login_password")
        can_submit = bool(st.session_state.get("login_username", "").strip())

        submitted = st.form_submit_button(
            "Entrar",
            type="primary",
            disabled=st.session_state.login_in_progress or not can_submit,
            on_click=lambda: st.session_state.update(
                {"login_in_progress": True, "login_error_message": None}
            ),
        )

        if login_error_message:
            st.error(login_error_message)

        if submitted:
            st.toast("Login em andamento. Aguarde..", icon=":material/login:")

            errors = []
            if not st.session_state.get("login_username", "").strip():
                errors.append("Informe o usu√°rio.")
            if not password:
                errors.append("Informe a senha.")

            if errors:
                st.session_state.login_in_progress = False
                for msg in errors:
                    st.error(msg)
            else:
                try:
                    with st.spinner("Entrando..."):
                        resp = api.login(st.session_state.get("login_username", ""), password)

                    if resp.status_code == 403:
                        try:
                            detail = resp.json().get("detail")
                        except Exception:
                            detail = None

                        if detail in ("PASSWORD_CHANGE_REQUIRED", "PASSWORD_EXPIRED"):
                            st.session_state.login_error_message = detail
                            raise ValueError(detail)

                    if resp.status_code != 200:
                        st.session_state.login_error_message = "Usu√°rio ou senha inv√°lidos"
                        # N√£o interrompe o app para manter o bot√£o "Esqueci minha senha"
                        raise ValueError("LOGIN_INVALID")

                    data = resp.json()

                    # üîê salva tokens sempre
                    st.session_state.access_token = data["access_token"]
                    st.session_state.refresh_token = data["refresh_token"]

                    # inicializa API client
                    st.session_state.api = APIClient(
                        base_url=settings.API_BASE_URL,
                        access_token=data["access_token"],
                        refresh_token=data["refresh_token"],
                    )
                    st.session_state.login_error_message = None

                    # üö® CASO ESPECIAL: senha pendente
                    if data.get("must_change_password"):
                        st.session_state.force_password_change = True
                        st.session_state.login_in_progress = False
                        print(Page.CHANGE_PASSWORD.path)
                        st.switch_page(Page.CHANGE_PASSWORD.path)
                        st.stop()

                    st.session_state.force_password_change = False
                    st.session_state.user = data["user"]
                    st.success("Login realizado com sucesso")
                    st.switch_page("Home.py")

                except Exception as e:
                    if str(e) == "LOGIN_INVALID" or str(e) == detail:
                        # erro j√° exibido acima
                        pass
                    else:
                        st.login_error_message = f"Erro ao conectar √† API: {e}"
                        # st.error(f"Erro ao conectar √† API: {e}")

                st.session_state.login_in_progress = False
                st.rerun()


st.divider()
if st.button("Esqueci minha senha"):
    forgot_password_dialog(prefill_username=st.session_state.get("login_username", ""))


==================================================
FILE: .\frontend\pages\1_üìÑ_Dados.py
==================================================
import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.loaders.registros import carregar_registros
from frontend.services.navigation import set_current_page

set_current_page(Page.DATA)

api, user = base_layout("Dados detalhados", ":paper:")

st.title("üìÑ Dados detalhados")

df = carregar_registros()

# reaproveita filtro da sess√£o
categoria = st.session_state.get("categoria")

if categoria:
    df = df[df["categoria"] == categoria]
    st.caption(f"Categoria selecionada: {categoria}")
else:
    st.caption("Nenhum filtro aplicado")

st.dataframe(df)


==================================================
FILE: .\frontend\pages\2_‚úèÔ∏è_Gerenciar.py
==================================================
import time

import requests
import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.loaders.registros import carregar_registros
from frontend.services.errors import handle_api_error
from frontend.services.navigation import set_current_page

set_current_page(Page.GERENCIAR)

api, user = base_layout("Gerenciar registros", ":pencil:")

# =====================
# üîê Seguran√ßa
# =====================

role = user["role"]

if role not in ("editor", "admin"):
    st.warning("Voc√™ n√£o tem permiss√£o para editar registros.")
    st.stop()

st.title("‚úèÔ∏è Gerenciar registros")

df = carregar_registros()

# ======================
# ‚ûï INSERIR
# ======================
st.subheader("‚ûï Novo registro")

with st.form("form_inserir", clear_on_submit=False):
    data = st.date_input("Data", format="DD/MM/YYYY")
    categoria = st.selectbox("Categoria", options=df["categoria"].unique())
    valor = st.number_input("Valor", step=1)

    submitted = st.form_submit_button("Inserir", type="primary")

if submitted:
    erros = []

    if not categoria.strip():
        erros.append("A categoria √© obrigat√≥ria.")

    if valor is None:
        erros.append("O valor √© obrigat√≥rio.")

    if erros:
        for erro in erros:
            st.error(erro, icon=":material/error:")
    else:
        try:
            resp = api.criar_registro(
                {
                    "data": str(data),
                    "categoria": categoria.strip(),
                    "valor": int(valor),
                }
            )

            handle_api_error(resp)

            if resp.status_code == 201:
                st.cache_data.clear()
                st.toast("Registro adicionado com sucesso.", icon=":material/check:")
                time.sleep(5)
                st.rerun()
            else:
                st.error(f"Erro ao inserir: {resp.text}")
        except requests.exceptions.HTTPError as e:
            st.error(f"Erro da API ({e.response.status_code})")
        except requests.exceptions.ConnectionError:
            st.error("N√£o foi poss√≠vel conectar √† API.")
        except Exception as e:
            st.error(f"Erro inesperado: {e}")


# ======================
# ‚úèÔ∏è EDITAR / üóëÔ∏è EXCLUIR
# ======================
st.subheader("‚úèÔ∏è Editar / üóëÔ∏è Excluir")

# üîç BUSCA REGISTROS =========

# st.subheader("üîç Buscar registro")


# inicializa√ß√£o
if "busca" not in st.session_state:
    st.session_state.busca = ""

if "busca_input" not in st.session_state:
    st.session_state.busca_input = st.session_state.busca

st.markdown(
    """
    <style>
    /* container da busca */
    div[data-testid="stVerticalBlock"]:has(> div > div > input[aria-label="üîç Buscar registro"]) {
        background-color: rgba(0, 123, 255, 0.08);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)


def on_busca_change():
    st.session_state.busca = st.session_state.busca_input


def limpar_busca():
    st.session_state.busca = ""
    st.session_state.busca_input = ""


with st.chat_message(
    "user",
    avatar='<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <rect width="24" height="24" fill="transparent"></rect><circle cx="12" cy="12" r="9" fill="#fff" /><path fill-rule="evenodd" clip-rule="evenodd" d="M2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM9 11.5C9 10.1193 10.1193 9 11.5 9C12.8807 9 14 10.1193 14 11.5C14 12.8807 12.8807 14 11.5 14C10.1193 14 9 12.8807 9 11.5ZM11.5 7C9.01472 7 7 9.01472 7 11.5C7 13.9853 9.01472 16 11.5 16C12.3805 16 13.202 15.7471 13.8957 15.31L15.2929 16.7071C15.6834 17.0976 16.3166 17.0976 16.7071 16.7071C17.0976 16.3166 17.0976 15.6834 16.7071 15.2929L15.31 13.8957C15.7471 13.202 16 12.3805 16 11.5C16 9.01472 13.9853 7 11.5 7Z" fill="#f74a36"></path></g></svg>',
):
    _, col_busca, col_limpar, _ = st.columns([0.5, 18, 2, 0.1], vertical_alignment="bottom")

    with col_busca:
        st.text_input(
            "Buscar registro",
            key="busca_input",
            placeholder="Categoria, valor ou data (ex: A, 50, 01/2025)",
            on_change=on_busca_change,
        )

    with col_limpar:
        st.button("‚ùå", help="Limpar busca", on_click=limpar_busca)


busca = st.session_state.busca.strip().lower()

df_filtrado = df.copy()

if busca:
    df_filtrado = df[
        df["id"].astype(str).str.contains(busca)
        | df["categoria"].str.lower().str.contains(busca)
        | df["valor"].astype(str).str.contains(busca)
        | df["data"].dt.strftime("%d/%m/%Y").str.contains(busca)
    ]

if df_filtrado.empty:
    st.warning("Nenhum registro encontrado.")
    st.stop()


def formatar_registro(row):
    return (
        f"[ ID {row['id']}] ‚ñ∂ Data: {row['data'].strftime('%d/%m/%Y')} , "
        f"Categoria: {row['categoria']} , "
        f"Valor: {row['valor']}"
    )


opcoes = {row["id"]: formatar_registro(row) for _, row in df_filtrado.iterrows()}


registro_id = st.selectbox(
    "Selecione o registro",
    options=list(opcoes.keys()),
    format_func=lambda x: opcoes[x],
)

registro = df_filtrado[df_filtrado["id"] == registro_id].iloc[0]

with st.form("form_editar", clear_on_submit=False):
    data_edit = st.date_input("Data", registro["data"], format="DD/MM/YYYY")
    categoria_edit = st.text_input("Categoria", registro["categoria"])
    valor_edit = st.number_input("Valor", value=int(registro["valor"]), step=1)

    col1, col2 = st.columns(2)
    salvar = col1.form_submit_button("Salvar altera√ß√µes", type="primary")
    if role == "admin":
        excluir = col2.form_submit_button("Excluir registro")

if salvar:
    try:
        resp = api.atualizar_registro(
            registro_id,
            {
                "data": str(data_edit),
                "categoria": categoria_edit.strip(),
                "valor": int(valor_edit),
            },
        )
        handle_api_error(resp)
        if resp.status_code == 200:
            st.cache_data.clear()
            st.toast("Registro atualizado com sucesso.", icon=":material/check:")
            time.sleep(1)
            st.rerun()
        else:
            st.error(f"Erro ao atualizar: {resp.text}")
    except Exception as e:
        st.error(f"Erro ao atualizar: {e}")


@st.dialog("‚ö†Ô∏è Confirmar exclus√£o")
def confirmar_exclusao(id_):
    st.error("Essa a√ß√£o n√£o pode ser desfeita.")
    st.write("Voc√™ est√° prestes a excluir o registro:")
    st.write(f"{opcoes[registro_id]}")
    st.write("")

    col1, col2 = st.columns(2)

    if col1.button("Cancelar"):
        st.rerun()

    if col2.button("Excluir definitivamente"):
        try:
            resp = api.deletar_registro(id_)
            handle_api_error(resp)
            if resp.status_code == 200:
                st.cache_data.clear()
                st.error("Registro exclu√≠do.")
                time.sleep(3)
                limpar_busca()
                st.rerun()
            else:
                st.error(f"Erro ao excluir: {resp.text}")
        except Exception as e:
            st.error(f"Erro ao excluir: {e}")


if role == "admin":
    if excluir:
        confirmar_exclusao(registro_id)


==================================================
FILE: .\frontend\pages\3_üìú_Auditoria.py
==================================================
import pandas as pd
import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.errors import handle_api_error
from frontend.services.navigation import set_current_page

set_current_page(Page.AUDITORIA)

api, user = base_layout("Auditoria", "üìú")

# =====================
# üîê Seguran√ßa
# =====================

if user["role"] != "admin":
    st.warning("Acesso restrito a administradores.")
    st.stop()

st.title("üìú Auditoria do Sistema")

# =====================
# üîé Filtros
# =====================
with st.expander("üîé Filtros", expanded=True):
    col1, col2, col3 = st.columns(3)

    with col1:
        username = st.text_input("Usu√°rio")

    with col2:
        action = st.selectbox(
            "A√ß√£o",
            options=["", "INSERT", "UPDATE", "DELETE", "PUT", "POST"],
        )

    with col3:
        resource = st.text_input("Recurso (ex: registros)")

    col4, col5 = st.columns(2)
    with col4:
        data_inicio = st.date_input("Data inicial", value=None, format="DD/MM/YYYY")

    with col5:
        data_fim = st.date_input("Data final", value=None, format="DD/MM/YYYY")

# =====================
# üì° Buscar auditoria
# =====================
params = {}

if username:
    params["username"] = username

if action:
    params["action"] = action

if resource:
    params["resource"] = resource

if data_inicio:
    params["data_inicio"] = data_inicio.isoformat()

if data_fim:
    params["data_fim"] = data_fim.isoformat()

try:
    resp = api.listar_auditoria(params)
    handle_api_error(resp)

    dados = resp.json()
    df = pd.DataFrame(dados)

except Exception as e:
    st.error(f"Erro ao carregar auditoria: {e}")
    st.stop()

# =====================
# üìä Exibi√ß√£o
# =====================
if df.empty:
    st.info("Nenhum evento encontrado com os filtros informados.")
    st.stop()

st.dataframe(
    df,
    width="stretch",
    hide_index=True,
)

# =====================
# üßæ Exporta√ß√£o CSV
# =====================
csv = df.to_csv(index=False).encode("utf-8")

st.download_button(
    label="üßæ Baixar CSV",
    data=csv,
    file_name="auditoria.csv",
    mime="text/csv",
)


==================================================
FILE: .\frontend\pages\4_üõ†Ô∏è_Administra√ß√£o.py
==================================================
import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.navigation import set_current_page

set_current_page(Page.ADMIN)

api, user = base_layout("Administra√ß√£o", ":material/handyman:", wide=True)

# =====================
# üîê Seguran√ßa
# =====================

if user["role"] != "admin":
    st.warning("Acesso restrito a administradores.")
    st.stop()

st.title("üõ†Ô∏è Administra√ß√£o")

# 1) Mostrar mensagem "flash" de sucesso (se existir) antes de desenhar o form
_flash = st.session_state.pop("flash_success", None)
if _flash:
    st.success(_flash)

# Se houver reset pendente, aplique AGORA (antes de instanciar os widgets)
if st.session_state.get("revoke_reset_pending"):
    st.session_state["revoke_username"] = ""
    st.session_state["revoke_confirm"] = False
    st.session_state.pop("revoke_reset_pending", None)

# Garanta defaults para as keys dos widgets (antes de criar o form)
st.session_state.setdefault("revoke_username", "")
st.session_state.setdefault("revoke_confirm", False)


st.header("üí£ Revogar sess√µes de um usu√°rio")

with st.form("revoke_user_sessions", clear_on_submit=False):
    # 2) D√™ chaves (keys) aos widgets para controlar o estado
    username = st.text_input("Username do usu√°rio", key="revoke_username")
    confirm = st.checkbox(
        "Confirmo que desejo revogar TODAS as sess√µes desse usu√°rio", key="revoke_confirm"
    )
    submitted = st.form_submit_button("Revogar sess√µes", type="primary")

    if submitted:
        if not username.strip():
            st.error("Informe o username")
        elif not confirm:
            st.warning("Confirma√ß√£o obrigat√≥ria")
        else:
            resp = api._request("POST", f"/admin/users/{username.strip()}/sessions/revoke")
            if resp.status_code == 200:
                # 4) Guarda a mensagem de sucesso para aparecer ap√≥s o rerun
                st.session_state["flash_success"] = f"Sess√µes de {username} revogadas com sucesso"
                st.session_state["revoke_reset_pending"] = True

                st.rerun()
            else:
                st.error(f"Erro ao revogar sess√µes: ({resp.status_code})")


st.header("üéØ Revogar sess√£o espec√≠fica")

with st.form("revoke_single_session", enter_to_submit=True):
    session_id = st.text_input("ID da sess√£o (session id)")
    confirm = st.checkbox("Confirmo que desejo revogar essa sess√£o")
    submitted = st.form_submit_button("Revogar sess√£o")

if submitted:
    if not session_id.strip():
        st.error("Informe o session_id.")
    elif not confirm:
        st.warning("Confirma√ß√£o obrigat√≥ria.")
    else:
        resp = api._request(
            "POST",
            f"/admin/sessions/{session_id.strip()}/revoke",
        )

        if resp.status_code == 200:
            st.success("Sess√£o revogada com sucesso.")
        else:
            st.error(f"Erro ao revogar sess√£o ({resp.status_code})")

st.divider()

st.header("üßπ Limpar sess√µes vencidas ou revogadas")
st.space("xxsmall")

left, right = st.columns(2)

with left:
    if st.button("Remover sess√µes expiradas", width="stretch"):
        resp = api._request(
            "POST",
            "/admin/sessions/cleanup",
        )

        if resp.status_code == 200:
            data = resp.json()
            st.success(f"{data['deleted_sessions']} sess√µes removidas.")
        else:
            st.error(f"Erro ao limpar sess√µes ({resp.status_code})")


with right:
    if st.button("Remover sess√µes revogadas", width="stretch"):
        resp = api._request(
            "POST",
            "/admin/sessions/revoked/cleanup",
        )

        if resp.status_code == 200:
            data = resp.json()
            st.success(f"{data['deleted_sessions']} sess√µes removidas.")
        else:
            st.error(f"Erro ao limpar sess√µes ({resp.status_code})")


==================================================
FILE: .\frontend\pages\5_üîê_Integridade_Auditoria.py
==================================================
import json

import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.navigation import set_current_page

set_current_page(Page.INTEGRIDADE)

api, user = base_layout("Integridade da Auditoria", "üîê", wide=True)

# =====================
# üîê Seguran√ßa
# =====================

if user["role"] != "admin":
    st.warning("Acesso restrito a administradores.")
    st.stop()

st.title("üîê Integridade da Auditoria")

col1, col2 = st.columns([3, 1])

with col2:
    if st.button(
        "üîÑ Reexecutar verifica√ß√£o",
        use_container_width=True,
    ):
        st.rerun()
    st.space()

# ============================
# üîé VERIFICA√á√ÉO DA CADEIA
# ============================

with st.spinner("Verificando integridade da auditoria..."):
    resp = api._request("GET", "/admin/audit/verify")

if resp.status_code != 200:
    st.error("Erro ao verificar auditoria.")
    st.stop()

result = resp.json()

# ============================
# üü¢ / üî¥ STATUS VISUAL
# ============================

if result["valid"]:
    st.success("‚úî Auditoria √≠ntegra e confi√°vel")
    st.metric("Eventos verificados", result.get("checked_events", 0))
else:
    st.error("‚ùå Viola√ß√£o detectada na auditoria")
    st.warning(f"Motivo: **{result['reason']}**")
    st.warning(f"Evento afetado (ID): **{result['broken_at_id']}**")

# ============================
# üßæ EXPORTA√á√ÉO
# ============================

st.divider()
st.subheader("üßæ Exportar relat√≥rio")

export_data = {
    "status": "valid" if result["valid"] else "broken",
    "details": result,
}

json_bytes = json.dumps(export_data, indent=2).encode("utf-8")

st.download_button(
    label="üì• Baixar relat√≥rio (JSON)",
    data=json_bytes,
    file_name="integridade_auditoria.json",
    mime="application/json",
)

# ============================
# ‚õî BLOQUEIO DE ESCRITA
# ============================

st.divider()
st.subheader("‚õî Prote√ß√£o do sistema")

if not result["valid"]:
    st.error(
        """
        ‚ö†Ô∏è **A auditoria foi comprometida.**

        Recomenda√ß√µes:
        - Bloquear novas opera√ß√µes de escrita
        - Investigar manualmente a base
        - Gerar evid√™ncias
        """
    )
else:
    st.info("Sistema liberado para opera√ß√µes de escrita.")


==================================================
FILE: .\frontend\pages\6_üßë‚Äçüíº_Usu√°rios.py
==================================================
import pandas as pd
import streamlit as st

from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.navigation import set_current_page

set_current_page(Page.USERS)

api, user = base_layout("Administra√ß√£o de Usu√°rios", "üßë‚Äçüíº", wide=True)

# =====================
# üîê Seguran√ßa
# =====================

# üîí P√°gina com acesso restrito ao perfil admin
if user["role"] != "admin":
    st.error("Acesso restrito a administradores.")
    st.stop()

st.title("üßë‚Äçüíº Administra√ß√£o de Usu√°rios")

response = api._request("GET", "/admin/users")

usuarios = response.json()

df = pd.DataFrame(usuarios)

st.dataframe(df, width="stretch")

st.divider()

st.subheader("üîÅ Reset de senha")

username = st.selectbox("Usu√°rio", df["username"].tolist())

if st.button("Resetar senha", type="primary"):
    resp = api._request("POST", f"/admin/users/{username}/reset-password")
    if resp.status_code == 200:
        senha = resp.json()
        st.success("Senha resetada com sucesso")
        st.divider()
        st.error("‚ö†Ô∏è Senha tempor√°ria gerada")
        st.code(senha["temporary_password"])
        st.caption("Copie agora. Ela n√£o ser√° exibida novamente.")
    else:
        st.error(f"Erro ao resetar senha: ({resp.status_code})")


==================================================
FILE: .\frontend\pages\7_üîë_Troca_de_Senha.py
==================================================
from time import sleep

import requests
import streamlit as st

from backend.core.config import settings
from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.navigation import set_current_page

set_current_page(Page.CHANGE_PASSWORD)

api, user = base_layout("Troca de Senha", "üîë")

carregando = st.session_state.get("loading_password_change")

if carregando is None:
    st.session_state.loading_password_change = False
    carregando = False

if carregando:
    st.markdown(
        """
        <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
            color: white;
            font-family: sans-serif;
        }

        .spinner {
            border: 6px solid rgba(255, 255, 255, 0.2);
            border-top: 6px solid #4CAF50;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .overlay-text {
            font-size: 22px;
            font-weight: 500;
        }

        .overlay-subtext {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 6px;
        }
        </style>

        <div class="overlay">
            <div class="spinner"></div>
            <div class="overlay-text">Atualizando sua senha...</div>
            <div class="overlay-subtext">Por favor aguarde.</div>
        </div>
        """,
        unsafe_allow_html=True,
    )

must_change_password = st.session_state.get("must_change_password")

error_message = st.session_state.get("error_message")


# if must_change_password is not None:
#     if not api or not user:
#         st.switch_page(Page.LOGIN.path)
#         st.stop()


st.title(f"üîë Troca {'obrigat√≥ria ' if must_change_password else ''}de senha")


# üîê Pol√≠tica de senha ‚Äî UX clara
with st.expander("üìã Pol√≠tica de senha", expanded=True):
    st.markdown("""
    Sua nova senha deve conter:
    - ‚úÖ **M√≠nimo de 6 caracteres**
    - üî† **Pelo menos uma Letra mai√∫scula**
    - üî° **Pelo menos uma Letra min√∫scula**
    - üî¢ **Pelo menos um N√∫mero**
    - üî£ **Pelo menos um Caractere especial** (`!@#$%^&*` etc)
    """)


def show_toast_errors(errors):
    for error in reversed(errors):
        st.toast(error, icon="‚ùå")
        sleep(0.5)


with st.form("change_password"):
    old = st.text_input("Senha atual", type="password")
    new = st.text_input("Nova senha", type="password")
    confirm = st.text_input("Confirmar nova senha", type="password")

    submitted = st.form_submit_button(
        "Alterar senha",
        on_click=lambda: st.session_state.update({"error_message": None}),
    )

    if error_message:
        st.toast(error_message, icon="‚ùå")
        st.session_state.error_message = None

    if submitted and not carregando:
        errors = []
        if not old:
            errors.append("Informe a senha atual")
        if not new:
            errors.append("Informe uma nova senha")
        if not confirm:
            errors.append("Confirme a nova senha")
        if new != confirm:
            errors.append("As senhas n√£o coincidem")

        if errors:
            st.session_state.login_in_progress = False
            show_toast_errors(errors)
            errors.clear()
            st.rerun()
        else:
            # üîí ativa overlay
            st.session_state.loading_password_change = True
            st.rerun()

if carregando:
    with st.spinner("Validando senha e atualizando sess√£o..."):
        resp = requests.post(
            f"{settings.API_BASE_URL}/admin/change-password",
            headers={"Authorization": f"Bearer {st.session_state.access_token}"},
            json={
                "old_password": old,
                "new_password": new,
            },
            timeout=10,
        )

    data = resp.json()

    if resp.status_code != 200:
        st.session_state.loading_password_change = False
        try:
            detail = data["detail"]
        except Exception:
            detail = "Erro ao alterar a senha"

        # st.error(detail)
        st.session_state.error_message = detail
        st.rerun()

    # ‚úÖ sucesso
    st.session_state.clear()
    st.toast("Senha alterada com sucesso", icon="‚úÖ")
    sleep(3)
    st.switch_page(Page.LOGIN.path)


==================================================
FILE: .\frontend\pages\8_üîë_Redefinir_Senha.py
==================================================
import time

import requests
import streamlit as st

from backend.core.config import settings
from frontend.app_config import init_page
from frontend.core.pages import Page
from frontend.services.navigation import set_current_page

token_from_link = st.session_state.get("reset_token_from_link", "")

set_current_page(Page.RESET_PASSWORD)

init_page(page_title="Redefinir senha", page_icon="üîë")
st.title("üîë Redefinir senha")

st.session_state.login_error_message = None
token = st.text_input("Token de redefini√ß√£o", value=token_from_link)
new_password = st.text_input("Nova senha", type="password")
confirm_password = st.text_input("Confirmar nova senha", type="password")

if st.button("Redefinir", type="primary"):
    if not token.strip():
        st.error("Informe o token.")
    elif not new_password:
        st.error("Informe a nova senha.")
    elif new_password != confirm_password:
        st.error("As senhas n√£o coincidem.")
    else:
        try:
            resp = requests.post(
                f"{settings.API_BASE_URL}/reset-password",
                json={"token": token.strip(), "new_password": new_password},
                timeout=10,
            )

            if resp.status_code >= 500:
                st.error("Erro interno ao redefinir a senha.")
            else:
                st.session_state.reset_token_from_link = None
                # üîí Sempre resposta gen√©rica
                st.success("Se o token for v√°lido, a senha ser√° redefinida.")
                time.sleep(5)
                st.switch_page(Page.LOGIN.path)
        except requests.exceptions.ConnectionError:
            st.error("N√£o foi poss√≠vel conectar √† API.")
        except Exception as exc:
            st.error(f"Erro inesperado: {exc}")


==================================================
FILE: .\frontend\pages\9_üë§_Perfil.py
==================================================
import time

import requests
import streamlit as st

from backend.core.config import settings
from frontend.core.pages import Page
from frontend.layouts.base_layout import base_layout
from frontend.services.navigation import set_current_page

# Define a p√°gina atual para controle de navega√ß√£o
set_current_page(Page.PROFILE)

# Usa o layout base
api, user = base_layout("Meu Perfil", "üë§")

# üîÑ Otimiza√ß√£o: S√≥ busca do backend se faltar dados essenciais (evita delay)
if not user.get("email"):
    try:
        resp = api._request("GET", "/me")
        if resp.status_code == 200:
            user = resp.json()
            st.session_state.user = user  # Atualiza sess√£o
    except Exception:
        pass

st.title("üë§ Meu Perfil")
st.caption("Gerencie suas informa√ß√µes pessoais e foto de perfil.")

# --- Layout em Colunas ---
col_info, col_avatar = st.columns([2, 1])

# --- Coluna 1: Dados Cadastrais ---
with col_info:
    st.subheader("üìù Dados Pessoais")
    with st.form("profile_form"):
        email = st.text_input("Email", value=user.get("email") or "")
        name = st.text_input("Nome de Exibi√ß√£o", value=user.get("name") or "")
        fullname = st.text_input("Nome Completo", value=user.get("fullname") or "")

        submitted = st.form_submit_button("Salvar Altera√ß√µes", type="primary")

        if submitted:
            try:
                resp = api._request(
                    "PUT", "/me/profile", json={"email": email, "name": name, "fullname": fullname}
                )

                if resp.status_code == 200:
                    # üîÑ Recarrega dados do backend para garantir consist√™ncia total
                    # (evita perder o avatar_path se o objeto local estiver desincronizado)
                    user_resp = api._request("GET", "/me")
                    if user_resp.status_code == 200:
                        st.session_state.user = user_resp.json()

                    st.success("Perfil atualizado com sucesso!")
                    st.rerun()
                else:
                    error_detail = resp.json().get("detail", "Erro ao atualizar")
                    if error_detail == "EMAIL_ALREADY_EXISTS":
                        st.error("Este e-mail j√° est√° em uso por outro usu√°rio.")
                    else:
                        st.error(f"Erro: {error_detail}")
            except Exception as e:
                st.error(f"Erro de conex√£o: {e}")

# --- Coluna 2: Avatar ---
with col_avatar:
    st.subheader("üì∏ Foto de Perfil")

    # Upload de nova foto
    uploaded_file = st.file_uploader("Alterar foto", type=["jpg", "png", "jpeg"])

    if uploaded_file:
        st.image(uploaded_file, width=150, caption="Pr√©-visualiza√ß√£o")

        if st.button("Salvar Nova Foto", type="primary"):
            with st.spinner("Enviando..."):
                try:
                    # Prepara o arquivo para envio multipart/form-data
                    files = {"file": (uploaded_file.name, uploaded_file, uploaded_file.type)}

                    # Usa requests direto aqui pois o wrapper api._request pode tentar serializar JSON
                    resp = requests.post(
                        f"{settings.API_BASE_URL}/me/avatar",
                        headers={"Authorization": f"Bearer {st.session_state.access_token}"},
                        files=files,
                        timeout=15,
                    )

                    if resp.status_code == 200:
                        # üîÑ Recarrega dados do backend para garantir consist√™ncia e URL atualizada
                        user_resp = api._request("GET", "/me")
                        if user_resp.status_code == 200:
                            st.session_state.user = user_resp.json()

                        st.success("Avatar atualizado!")
                        st.rerun()
                    else:
                        st.error(f"Erro no upload: {resp.text}")
                except Exception as e:
                    st.error(f"Erro ao enviar arquivo: {e}")
    else:
        # Exibe avatar atual
        avatar_path = user.get("avatar_path")
        if avatar_path:
            if avatar_path.startswith("/"):
                # ?v=timestamp for√ßa o navegador a recarregar a imagem (cache busting)
                img_url = f"{settings.API_BASE_URL}{avatar_path}?v={int(time.time())}"
            else:
                img_url = avatar_path
        else:
            nome = user.get("name") or user.get("username") or "User"
            img_url = f"https://ui-avatars.com/api/?name={nome}&background=random&size=150"

        st.image(img_url, width=150, caption="Avatar Atual")


==================================================
FILE: .\frontend\services\api.py
==================================================
import json
import logging
import sys

import requests
import streamlit as st

from backend.core.config import settings
from frontend.core.pages import Page
from frontend.services.navigation import get_current_page

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s"))
    logger.addHandler(handler)


class APIClient:
    def __init__(self, base_url: str, access_token: str, refresh_token: str):
        self.base_url = base_url.rstrip("/")
        self.access_token = access_token
        self.refresh_token = refresh_token
        self.timeout = 10

    # -------------------------
    # Helpers internos
    # -------------------------

    def _headers(self):
        return {
            "Authorization": f"Bearer {self.access_token}",
        }

    def ensure_user_refresh(self):
        """
        For√ßa uma chamada leve ao backend apenas para sincronizar contexto.
        """
        resp = self._request("GET", "/me")

        if resp.status_code != 200:
            return False

        return True

    def _sync_user_from_headers(self, resp):
        logger.debug("Sincronizando dados de usu√°rio...")
        header = resp.headers.get("X-User-Context")

        if not header:
            return

        try:
            data = json.loads(header)
            st.session_state.user = data
        except Exception as e:
            logger.error(f"Erro ao decodificar X-User-Context: {e}")

    def _refresh_acess_token(self) -> bool:
        """'
        Tenta renovar o access token usando o refresh token.
        Retorna True se conseguiu, False se falhou.
        """
        resp = requests.post(
            f"{self.base_url}/refresh",
            headers={
                "Authorization": f"Bearer {self.refresh_token}",
            },
        )
        if resp.status_code != 200:
            return False

        data = resp.json()

        self.access_token = data["access_token"]
        self.refresh_token = data["refresh_token"]

        # sincroniza com o session_state
        st.session_state.access_token = self.access_token
        st.session_state.refresh_token = self.refresh_token

        return True

    def _request(self, method: str, path: str, **kwargs):
        """
        Request gen√©rico com retry autom√°tico via refresh token.
        """
        resp = requests.request(
            method,
            f"{self.base_url}{path}",
            headers=self._headers(),
            **kwargs,
        )

        self._sync_user_from_headers(resp)

        if resp.status_code == 403:
            try:
                detail = resp.json().get("detail")
            except Exception:
                detail = None

            current_page = get_current_page()

            if detail in ("PASSWORD_CHANGE_REQUIRED", "PASSWORD_EXPIRED"):
                if current_page != Page.CHANGE_PASSWORD.key:
                    # ‚ö†Ô∏è Apenas em desenvolvimento, retorna o token no response
                    if settings.ENV == "dev":
                        logger.warning(f"Password change required or expired. Detail: {detail}")

                    st.session_state.force_password_change = True
                    st.switch_page(Page.CHANGE_PASSWORD.path)
                    st.stop()

        # üîÅ fluxo normal de refresh
        if resp.status_code != 401:
            return resp

        # tenta refresh
        if not self._refresh_acess_token():
            self._force_logout()
            return resp

        # retry UMA vez
        return requests.request(
            method,
            f"{self.base_url}{path}",
            headers=self._headers(),
            **kwargs,
        )

    def _force_logout(self):
        st.session_state.api = None
        st.session_state.user = None
        st.session_state.access_token = None
        st.session_state.refresh_token = None
        st.switch_page(Page.LOGIN.path)

    # -------------------------
    # M√©todos p√∫blicos (sem auth)
    # -------------------------

    @staticmethod
    def listar_registros_publico(base_url: str, timeout: int = 10):
        return requests.get(
            f"{base_url.rstrip('/')}/registros",
            timeout=timeout,
        )

    # -------------------------
    # M√©todos p√∫blicos (com auth)
    # -------------------------

    def listar_registros(self):
        return self._request("GET", "/registros", timeout=self.timeout)

    def criar_registro(self, payload: dict):
        return self._request("POST", "/registros", json=payload, timeout=self.timeout)

    def atualizar_registro(self, id_: int, payload: dict):
        return self._request("PUT", f"/registros/{id_}", json=payload, timeout=self.timeout)

    def deletar_registro(self, id_: int):
        return self._request("DELETE", f"/registros/{id_}", timeout=self.timeout)

    def listar_auditoria(self, params: dict):
        return self._request("GET", "/auditoria", params=params, timeout=self.timeout)

    def logout(self):
        return requests.post(
            f"{self.base_url}/logout",
            headers=self._headers(),
            timeout=self.timeout,
        )

    def login(self, username: str, password: str):
        return requests.post(
            f"{self.base_url}/login",
            params={
                "username": username,
                "password": password,
            },
            timeout=self.timeout,
        )


==================================================
FILE: .\frontend\services\errors.py
==================================================
import streamlit as st

from frontend.core.pages import Page

__all__ = ["handle_api_error"]

# print(">>> carregando errors.py")
# print(">>> globals:", list(globals().keys()))


def handle_api_error(resp):
    if resp.status_code == 401:
        st.error("Sess√£o expirada ou credenciais inv√°lidas.")
        st.session_state.api = None
        st.switch_page(Page.LOGIN.path)
        st.stop()

    if resp.status_code == 403:
        st.error("Voc√™ n√£o tem permiss√£o para executar esta a√ß√£o.")
        st.stop()

    if resp.status_code == 423:
        try:
            detail = resp.json().get("detail", "Sistema bloqueado.")
        except Exception:
            detail = "Sistema bloqueado."
        st.error(f"‚õî {detail}")
        st.stop()

    if resp.status_code >= 500:
        st.error("Erro interno no servidor.")
        st.stop()


==================================================
FILE: .\frontend\services\navigation.py
==================================================
import streamlit as st

from frontend.core.pages import Page


def set_current_page(page: Page):
    st.session_state["_page"] = page.key


def get_current_page() -> str | None:
    return st.session_state.get("_page")


==================================================
FILE: .\frontend\services\session.py
==================================================
import logging
import sys
import time

import streamlit as st

from backend.core.config import settings
from frontend.core.pages import Page

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

if not logger.handlers:
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s"))
    logger.addHandler(handler)


def require_auth():
    api = st.session_state.get("api")
    user = st.session_state.get("user")

    if not api or not user:
        st.switch_page(Page.LOGIN.path)
        st.stop()

    # Otimiza√ß√£o: Valida no backend apenas a cada 5 minutos (300s)
    last_check = st.session_state.get("last_auth_check", 0)
    now = time.time()
    cache_duration = 300  # 5 minutos

    if (now - last_check) > cache_duration:
        with st.spinner("Verificando sess√£o..."):  # Opcional: remover spinner para ser transparente
            logger.info("Check de permiss√£o e sess√£o iniciada.")
            # chamada leve para validar sess√£o
            valid = api.ensure_user_refresh()

        if not valid:
            st.session_state.clear()
            st.switch_page(Page.LOGIN.path)
            st.stop()

        st.session_state["last_auth_check"] = now
    elif settings.ENV == "dev":
        logger.info("Verifica√ß√£o de sess√£o pulada (cache ativo).")

    return api, user


==================================================
FILE: .\frontend\services\__init__.py
==================================================


==================================================
FILE: .\frontend\util\greeting.py
==================================================
from datetime import datetime


def saudacao_usuario(nome: str) -> str:
    hora = datetime.now().hour
    if 5 <= hora < 12:
        periodo = "Bom dia"
    elif 12 <= hora < 18:
        periodo = "Boa tarde"
    else:
        periodo = "Boa noite"

    # Pega apenas o primeiro nome se for composto
    primeiro_nome = nome.split()[0] if nome else "Usu√°rio"
    return f"{periodo}, {primeiro_nome}!"


==================================================
FILE: .\migrations\V001__create_registros.py
==================================================
def upgrade(conn):
    """
    Cria a tabela 'registros' se n√£o existir e insere um seed inicial de forma idempotente.
    """
    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS registros (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            data TEXT NOT NULL,
            categoria TEXT NOT NULL,
            valor INTEGER NOT NULL
        )
        """
    )

    # Seed idempotente: s√≥ insere se a tabela estiver vazia
    cur = conn.execute("SELECT COUNT(*) FROM registros")
    (count,) = cur.fetchone()
    if count == 0:
        dados = [
            ("2025-01-01", "A", 10),
            ("2025-01-02", "A", 15),
            ("2025-01-03", "B", 8),
            ("2025-01-04", "B", 20),
            ("2025-01-05", "A", 7),
        ]
        conn.executemany(
            "INSERT INTO registros (data, categoria, valor) VALUES (?, ?, ?)", dados
        )


==================================================
FILE: .\migrations\V002__auditoria_registros.py
==================================================
"""
V002 ‚Äî Camada de auditoria (compat√≠vel e idempotente).
- Garante colunas criado_em, atualizado_em, origem.
- Backfill nos valores NULL.
- (Re)cria gatilhos de auditoria.
- Cria √≠ndices se faltarem.
"""


def upgrade(conn):
    def has_column(table: str, col: str) -> bool:
        rows = conn.execute(f"PRAGMA table_info({table})").fetchall()
        names = {r[1] for r in rows}  # r[1] = nome da coluna
        return col in names

    def trigger_exists(name: str) -> bool:
        sql = "SELECT 1 FROM sqlite_master WHERE type='trigger' AND name=?"
        return conn.execute(sql, (name,)).fetchone() is not None

    def index_exists(name: str) -> bool:
        sql = "SELECT 1 FROM sqlite_master WHERE type='index' AND name=?"
        return conn.execute(sql, (name,)).fetchone() is not None

    # 1) Colunas (checa antes de adicionar)
    if not has_column("registros", "criado_em"):
        conn.execute("ALTER TABLE registros ADD COLUMN criado_em TEXT")
    if not has_column("registros", "atualizado_em"):
        conn.execute("ALTER TABLE registros ADD COLUMN atualizado_em TEXT")
    if not has_column("registros", "origem"):
        conn.execute("ALTER TABLE registros ADD COLUMN origem TEXT")

    # 2) Backfill
    conn.execute(
        """
        UPDATE registros
           SET criado_em     = COALESCE(criado_em, CURRENT_TIMESTAMP),
               atualizado_em = COALESCE(atualizado_em, CURRENT_TIMESTAMP),
               origem        = COALESCE(origem, 'script_migracao')
         WHERE criado_em IS NULL
            OR atualizado_em IS NULL
            OR origem IS NULL
        """
    )

    # 3) Triggers ‚Äî drop se existir e recria
    if trigger_exists("trg_registros_set_atualizado_em"):
        conn.execute("DROP TRIGGER trg_registros_set_atualizado_em")
    conn.executescript(
        """
        CREATE TRIGGER trg_registros_set_atualizado_em
        AFTER UPDATE ON registros
        FOR EACH ROW
        WHEN NEW.atualizado_em IS OLD.atualizado_em
        BEGIN
            UPDATE registros
               SET atualizado_em = CURRENT_TIMESTAMP
             WHERE id = NEW.id;
        END;
        """
    )

    if trigger_exists("trg_registros_set_criado_em_default"):
        conn.execute("DROP TRIGGER trg_registros_set_criado_em_default")
    conn.executescript(
        """
        CREATE TRIGGER trg_registros_set_criado_em_default
        AFTER INSERT ON registros
        FOR EACH ROW
        WHEN NEW.criado_em IS NULL
        BEGIN
            UPDATE registros
               SET criado_em = CURRENT_TIMESTAMP
             WHERE id = NEW.id;
        END;
        """
    )

    if trigger_exists("trg_registros_set_origem_default"):
        conn.execute("DROP TRIGGER trg_registros_set_origem_default")
    conn.executescript(
        """
        CREATE TRIGGER trg_registros_set_origem_default
        AFTER INSERT ON registros
        FOR EACH ROW
        WHEN NEW.origem IS NULL
        BEGIN
            UPDATE registros
               SET origem = 'script_migracao'
             WHERE id = NEW.id;
        END;
        """
    )

    # 4) √çndices (checa antes de criar)
    if not index_exists("idx_registros_criado_em"):
        conn.execute("CREATE INDEX idx_registros_criado_em ON registros(criado_em)")
    if not index_exists("idx_registros_atualizado_em"):
        conn.execute(
            "CREATE INDEX idx_registros_atualizado_em ON registros(atualizado_em)"
        )


==================================================
FILE: .\migrations\V003__unicidade_upsert_e_wal.py
==================================================
"""
V003 ‚Äî Unicidade por (data, categoria), upsert via view e WAL mode.

Passos:
1) Remove duplicados preservando o mais recente por (data, categoria).
2) Cria √≠ndice √öNICO em (data, categoria) e √≠ndice auxiliar (categoria, data).
3) Cria view + gatilho INSTEAD OF INSERT para upsert.
4) Ativa WAL mode e synchronous=NORMAL (fora de transa√ß√£o).
"""


def upgrade(conn):
    # 1) Remo√ß√£o idempotente de duplicados por (data, categoria)
    conn.executescript(
        """
        WITH ranked AS (
            SELECT
                id,
                data,
                categoria,
                ROW_NUMBER() OVER (
                    PARTITION BY data, categoria
                    ORDER BY COALESCE(atualizado_em, criado_em) DESC, id DESC
                ) AS rn
            FROM registros
        )
        DELETE FROM registros
        WHERE id IN (SELECT id FROM ranked WHERE rn > 1);
        """
    )

    # 2) √çndices (UNIQUE e auxiliar)
    conn.executescript(
        """
        CREATE UNIQUE INDEX IF NOT EXISTS ux_registros_data_categoria
            ON registros (data, categoria);

        CREATE INDEX IF NOT EXISTS ix_registros_categoria_data
            ON registros (categoria, data);
        """
    )

    # 3) View + gatilho de UPSERT
    conn.executescript(
        """
        DROP TRIGGER IF EXISTS trg_vw_registros_upsert_insert;
        DROP VIEW IF EXISTS vw_registros_upsert;

        CREATE VIEW IF NOT EXISTS vw_registros_upsert AS
        SELECT id, data, categoria, valor, criado_em, atualizado_em, origem
        FROM registros;

        CREATE TRIGGER trg_vw_registros_upsert_insert
        INSTEAD OF INSERT ON vw_registros_upsert
        FOR EACH ROW
        BEGIN
            INSERT INTO registros (data, categoria, valor, origem)
            VALUES (NEW.data, NEW.categoria, NEW.valor, NEW.origem)
            ON CONFLICT(data, categoria) DO UPDATE SET
                valor          = excluded.valor,
                origem         = COALESCE(excluded.origem, registros.origem),
                atualizado_em  = CURRENT_TIMESTAMP;
        END;
        """
    )

    # 4) Ativa WAL fora de transa√ß√£o: faz um commit expl√≠cito e aplica PRAGMAs
    conn.commit()  # encerra a transa√ß√£o aberta pelo runner (IMPORTANTE)
    conn.execute("PRAGMA journal_mode=WAL")
    conn.execute("PRAGMA synchronous=NORMAL")


==================================================
FILE: .\migrations\V004__create_auditoria.sql
==================================================
CREATE TABLE auditoria (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    username TEXT NOT NULL,
    role TEXT NOT NULL,
    action TEXT NOT NULL,
    resource TEXT NOT NULL,
    resource_id INTEGER,
    payload_before TEXT,
    payload_after TEXT,
    endpoint TEXT NOT NULL,
    method TEXT NOT NULL
);


==================================================
FILE: .\migrations\V005__sessions.sql
==================================================
CREATE TABLE IF NOT EXISTS user_sessions (
    id TEXT PRIMARY KEY,
    username TEXT NOT NULL,
    role TEXT NOT NULL,
    created_at TEXT NOT NULL,
    expires_at TEXT NOT NULL,
    revoked INTEGER NOT NULL DEFAULT 0
);


==================================================
FILE: .\migrations\V006__add_audit_hash_chain.sql
==================================================
ALTER TABLE auditoria ADD COLUMN prev_hash TEXT;
ALTER TABLE auditoria ADD COLUMN event_hash TEXT;

-- √≠ndice ajuda na verifica√ß√£o sequencial
CREATE INDEX IF NOT EXISTS idx_auditoria_id ON auditoria(id);


==================================================
FILE: .\migrations\V007__users_table.sql
==================================================
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    role TEXT NOT NULL,
    is_active INTEGER DEFAULT 1,
    created_at TEXT NOT NULL
);


==================================================
FILE: .\migrations\V008__must_change_password.sql
==================================================
ALTER TABLE users
ADD COLUMN must_change_password INTEGER DEFAULT 0;

==================================================
FILE: .\migrations\V009__password_reset_tokens.sql
==================================================
-- 005_password_reset_tokens.sql

CREATE TABLE IF NOT EXISTS password_reset_tokens (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    username TEXT NOT NULL,
    token_hash TEXT NOT NULL,

    created_at TEXT NOT NULL,
    expires_at TEXT NOT NULL,
    used_at TEXT,

    FOREIGN KEY (username) REFERENCES users(username)
);

CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_username
    ON password_reset_tokens(username);

CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token_hash
    ON password_reset_tokens(token_hash);


==================================================
FILE: .\migrations\V010__password_changed_at.sql
==================================================
ALTER TABLE users
ADD COLUMN password_changed_at TIMESTAMP;

==================================================
FILE: .\migrations\V011__password_expiration.sql
==================================================
ALTER TABLE users ADD COLUMN password_expires_at TEXT;
UPDATE users
-- SET password_expires_at = datetime('now', '+90 days')
SET password_expires_at = strftime('%Y-%m-%dT%H:%M:%SZ', 'now', '+90 days')
WHERE password_expires_at IS NULL;

==================================================
FILE: .\migrations\V012__users_email.sql
==================================================
ALTER TABLE users ADD COLUMN email TEXT;

CREATE UNIQUE INDEX IF NOT EXISTS ux_users_email
ON users(email);

==================================================
FILE: .\migrations\V013__users_profile_fields.sql
==================================================
ALTER TABLE users ADD COLUMN name TEXT;
ALTER TABLE users ADD COLUMN fullname TEXT;
ALTER TABLE users ADD COLUMN avatar_path TEXT;

==================================================
FILE: .\migrations\V014__audit_integrity.sql
==================================================
CREATE TABLE audit_integrity (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    status TEXT NOT NULL DEFAULT 'OK', -- 'OK' | 'VIOLATED'
    last_check_at TEXT,
    violated_at TEXT,
    violated_event_id INTEGER,
    reason TEXT
);

-- Inicializa com estado saud√°vel
INSERT INTO audit_integrity (id, status, last_check_at)
VALUES (1, 'OK', CURRENT_TIMESTAMP);

==================================================
FILE: .\scripts\start_all.sh
==================================================

#!/usr/bin/env bash
set -euo pipefail
# Inicia backend e frontend; encerra backend ao sair
cd "$(dirname "$0")/.."
export PYTHONPATH="$PWD"

uvicorn backend.main:app --reload &
BACK_PID=$!
cleanup(){ kill "$BACK_PID" 2>/dev/null || true; }
trap cleanup EXIT

# Opcional: aguarda backend subir se curl existir
READY=0
if command -v curl >/dev/null 2>&1; then
  for i in {1..30}; do
    if curl -fsS http://127.0.0.1:8000/docs >/dev/null 2>&1; then READY=1; break; fi
    sleep 0.3
  done
fi
[ "$READY" -eq 1 ] && echo "[ok] backend no ar em http://127.0.0.1:8000" || echo "[info] seguindo sem checar disponibilidade do backend"

# Streamlit em primeiro plano
exec streamlit run frontend/Home.py
``


==================================================
FILE: .\scripts\start_all_windows.bat
==================================================

@echo off
REM Abre backend e frontend em janelas separadas do CMD
cd /d "%~dp0\.."
set "PYTHONPATH=%CD%"
start "Uvicorn (backend)" cmd /k "set PYTHONPATH=%PYTHONPATH% && uvicorn backend.main:app --reload"
start "Streamlit (frontend)" cmd /k "set PYTHONPATH=%PYTHONPATH% && streamlit run frontend\Home.py"
echo [OK] Backend e frontend foram iniciados em janelas separadas.


==================================================
FILE: .\scripts\start_backend.bat
==================================================

@echo off
REM Inicia o backend (Uvicorn) a partir da raiz do projeto
cd /d "%~dp0\.."
set PYTHONPATH=%CD%
uvicorn backend.main:app --reload


==================================================
FILE: .\scripts\start_backend.sh
==================================================

#!/usr/bin/env bash
set -euo pipefail
# Inicia o backend (Uvicorn) a partir da raiz do projeto
cd "$(dirname "$0")/.."
export PYTHONPATH="$PWD"
exec uvicorn backend.main:app --reload


==================================================
FILE: .\scripts\start_frontend.bat
==================================================

@echo off
REM Inicia o frontend (Streamlit) a partir da raiz do projeto
cd /d "%~dp0\.."
set PYTHONPATH=%CD%
streamlit run frontend\Home.py


==================================================
FILE: .\scripts\start_frontend.sh
==================================================

#!/usr/bin/env bash
set -euo pipefail
# Inicia o frontend (Streamlit) a partir da raiz do projeto
cd "$(dirname "$0")/.."
export PYTHONPATH="$PWD"
exec streamlit run frontend/Home.py
``


==================================================
FILE: .\v1 - only streamlit\app.py
==================================================
import streamlit as st
from charts.charts import grafico_evolucao
from data.loader import carregar_dados

st.set_page_config(page_title="Painel Evolutivo de Dados", layout="wide")
st.title("üìä Painel Evolutivo de Dados")

df = carregar_dados()

# --- ler query params ---
query_params = st.query_params
categoria_qp = query_params.get("categoria", [None])[0]

# --- inicializar estado ---
if "categoria" not in st.session_state:
    st.session_state.categoria = categoria_qp or df["categoria"].iloc[0]

categorias = df["categoria"].unique()

# --- sidebar ---
with st.sidebar:
    try:
        cat_idx = categorias.tolist().index(st.session_state.categoria)
    except ValueError:
        cat_idx = 0

    categoria = st.selectbox(
        "Categoria",
        options=df["categoria"].unique(),
        index=cat_idx,
    )

    st.divider()

    if st.button("Recarregar dados"):
        st.cache_data.clear()
        st.success("Dados recarregados")
        st.rerun()


# --- salvar no estado e na URL ---
st.session_state.categoria = categoria
st.query_params.categoria = categoria


df_filtrado = df[df["categoria"] == categoria]

st.markdown(
    """
    <style>
    div[data-testid="stHorizontalBlock"] > div:nth-child(2) {
        padding-left: 50px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)

# --- layout ---
col1, col2 = st.columns([2, 1])

with col1:
    fig = grafico_evolucao(df_filtrado, categoria)
    st.plotly_chart(fig, width="stretch")

with col2:
    st.metric(label="Total de registros", value=len(df_filtrado))
    st.metric(label="Soma do valor", value=df_filtrado["valor"].sum())


==================================================
FILE: .\v1 - only streamlit\create_sqlite_database.py
==================================================
import sqlite3
from pathlib import Path

db_path = Path.cwd() / "painel_dados_chatgpt_tutorial" / "data" / "dados.db"
db_path.parent.mkdir(exist_ok=True)

conn = sqlite3.connect(db_path)

cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS registros (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    data TEXT NOT NULL,
    categoria TEXT NOT NULL,
    valor INTEGER NOT NULL
)
""")

dados = [
    ("2025-01-01", "A", 10),
    ("2025-01-02", "A", 15),
    ("2025-01-03", "B", 8),
    ("2025-01-04", "B", 20),
    ("2025-01-05", "A", 7),
]

cursor.execute("DELETE FROM registros")
cursor.executemany(
    "INSERT INTO registros (data, categoria, valor) VALUES (?, ?, ?)", dados
)

conn.commit()
conn.close()

print("Banco criado com sucesso.")


==================================================
FILE: .\v1 - only streamlit\requirements.txt
==================================================
streamlit
pandas
plotly
fastapi
uvicorn
python-multipart
python-jose[cryptography]
passlib[bcrypt]
slowapi
requests


==================================================
FILE: .\v1 - only streamlit\charts\charts.py
==================================================
import plotly.express as px


def grafico_evolucao(df, categoria):
    fig = px.line(df, x="data", y="valor", title=f"Evolu√ß√£o da categoria {categoria}")
    return fig


==================================================
FILE: .\v1 - only streamlit\pages\1_üìÑ_Dados.py
==================================================
import streamlit as st
from data.loader import carregar_dados

st.title("üìÑ Dados detalhados")

df = carregar_dados()

# reaproveita filtro da sess√£o
categoria = st.session_state.get("categoria")

if categoria:
    df = df[df["categoria"] == categoria]
    st.caption(f"Categoria selecionada: {categoria}")
else:
    st.caption("Nenhum filtro aplicado")

st.dataframe(df)


==================================================
FILE: .\v1 - only streamlit\pages\2_‚úèÔ∏è_Gerenciar.py
==================================================
import time

import streamlit as st
from data.crud import (
    atualizar_registro,
    deletar_registro,
    inserir_registro,
)
from data.loader import carregar_dados

st.title("‚úèÔ∏è Gerenciar registros")

df = carregar_dados()

# ======================
# ‚ûï INSERIR
# ======================
st.subheader("‚ûï Novo registro")

with st.form("form_inserir", clear_on_submit=False):
    data = st.date_input("Data", format="DD/MM/YYYY")
    categoria = st.selectbox("Categoria", options=df["categoria"].unique())
    valor = st.number_input("Valor", step=1)

    submitted = st.form_submit_button("Inserir", type="primary")

if submitted:
    erros = []

    if not categoria.strip():
        erros.append("A categoria √© obrigat√≥ria.")

    if valor is None:
        erros.append("O valor √© obrigat√≥rio.")

    if erros:
        for erro in erros:
            st.error(erro, icon=":material/error:")
    else:
        inserir_registro(str(data), categoria, int(valor))
        st.cache_data.clear()
        st.toast("Registro adicionado com sucesso.", icon=":material/check:")
        time.sleep(5)
        st.rerun()

# ======================
# ‚úèÔ∏è EDITAR / üóëÔ∏è EXCLUIR
# ======================
st.subheader("‚úèÔ∏è Editar / üóëÔ∏è Excluir")

# üîç BUSCA REGISTROS =========

# st.subheader("üîç Buscar registro")


def on_busca_change():
    st.session_state.busca = st.session_state.busca_input


def limpar_busca():
    st.session_state.busca = ""
    st.session_state.busca_input = ""


# inicializa√ß√£o
if "busca" not in st.session_state:
    st.session_state.busca = ""

if "busca_input" not in st.session_state:
    st.session_state.busca_input = st.session_state.busca

st.markdown(
    """
    <style>
    /* container da busca */
    div[data-testid="stVerticalBlock"]:has(> div > div > input[aria-label="üîç Buscar registro"]) {
        background-color: rgba(0, 123, 255, 0.08);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
    }
    </style>
    """,
    unsafe_allow_html=True,
)

with st.chat_message(
    "user",
    avatar='<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <rect width="24" height="24" fill="transparent"></rect><circle cx="12" cy="12" r="9" fill="#fff" /><path fill-rule="evenodd" clip-rule="evenodd" d="M2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM9 11.5C9 10.1193 10.1193 9 11.5 9C12.8807 9 14 10.1193 14 11.5C14 12.8807 12.8807 14 11.5 14C10.1193 14 9 12.8807 9 11.5ZM11.5 7C9.01472 7 7 9.01472 7 11.5C7 13.9853 9.01472 16 11.5 16C12.3805 16 13.202 15.7471 13.8957 15.31L15.2929 16.7071C15.6834 17.0976 16.3166 17.0976 16.7071 16.7071C17.0976 16.3166 17.0976 15.6834 16.7071 15.2929L15.31 13.8957C15.7471 13.202 16 12.3805 16 11.5C16 9.01472 13.9853 7 11.5 7Z" fill="#f74a36"></path></g></svg>',
):
    _, col_busca, col_limpar, _ = st.columns(
        [0.5, 18, 2, 0.1], vertical_alignment="bottom"
    )

    with col_busca:
        st.text_input(
            "Buscar registro",
            key="busca_input",
            placeholder="Categoria, valor ou data (ex: A, 50, 01/2025)",
            on_change=on_busca_change,
        )

    with col_limpar:
        st.button("‚ùå", help="Limpar busca", on_click=limpar_busca)


busca = st.session_state.busca.strip().lower()

df_filtrado = df.copy()

if busca:
    df_filtrado = df[
        df["id"].astype(str).str.contains(busca)
        | df["categoria"].str.lower().str.contains(busca)
        | df["valor"].astype(str).str.contains(busca)
        | df["data"].dt.strftime("%d/%m/%Y").str.contains(busca)
    ]

if df_filtrado.empty:
    st.warning("Nenhum registro encontrado.")
    st.stop()


def formatar_registro(row):
    return (
        f"[ ID {row['id']}] ‚ñ∂ Data: {row['data'].strftime('%d/%m/%Y')} , "
        f"Categoria: {row['categoria']} , "
        f"Valor: {row['valor']}"
    )


opcoes = {row["id"]: formatar_registro(row) for _, row in df_filtrado.iterrows()}


registro_id = st.selectbox(
    "Selecione o registro",
    options=list(opcoes.keys()),
    format_func=lambda x: opcoes[x],
)

registro = df_filtrado[df_filtrado["id"] == registro_id].iloc[0]

with st.form("form_editar", clear_on_submit=True):
    data_edit = st.date_input("Data", registro["data"], format="DD/MM/YYYY")
    categoria_edit = st.text_input("Categoria", registro["categoria"])
    valor_edit = st.number_input("Valor", value=int(registro["valor"]), step=1)

    col1, col2 = st.columns(2)
    salvar = col1.form_submit_button("Salvar altera√ß√µes", type="primary")
    excluir = col2.form_submit_button("Excluir registro")

if salvar:
    atualizar_registro(
        registro_id,
        str(data_edit),
        categoria_edit,
        int(valor_edit),
    )
    st.cache_data.clear()
    st.toast("Registro atualizado com sucesso.", icon=":material/check:")
    time.sleep(5)
    st.rerun()


@st.dialog("‚ö†Ô∏è Confirmar exclus√£o")
def confirmar_exclusao(id_):
    st.error("Essa a√ß√£o n√£o pode ser desfeita.")
    st.write("Voc√™ est√° prestes a excluir o registro:")
    st.write(f"{opcoes[registro_id]}")
    st.write("")

    col1, col2 = st.columns(2)

    if col1.button("Cancelar"):
        st.rerun()

    if col2.button("Excluir definitivamente"):
        deletar_registro(id_)
        st.cache_data.clear()
        st.error("Registro exclu√≠do.")
        time.sleep(3)
        limpar_busca()
        st.rerun()


if excluir:
    confirmar_exclusao(registro_id)
